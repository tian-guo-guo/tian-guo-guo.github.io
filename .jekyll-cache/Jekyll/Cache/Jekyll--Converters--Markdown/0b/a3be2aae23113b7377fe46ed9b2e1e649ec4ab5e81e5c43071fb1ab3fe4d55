I"ȃ<h1 id="leecode-write">LeeCode-write</h1>

<h1 id="数字">数字</h1>

<h2 id="leetcode-07-整数反转-个位取值">LeetCode-07-整数反转-个位取值</h2>

<p><strong>题目：</strong>
 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
 输入: 123 输出: 321 输入: -123  输出: -321 输入: 120  输出: 21</p>

<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。[-214783648, 214783647]，如果反转后整数溢出那么就返回 0。
<strong>思路：</strong></p>

<p>先不考虑符号，用abs，然后while loop这个数，个位temp：通过取余获得，数值num：存到num里，num每一轮都扩大10倍，左移一位，然后把temp加到最右边，余下的数a：因为已经把个位数移掉了，只需要保留10位数和10位数以上的数，a=int(a/10)。然后下一步判断输入是正还是负，以及索引越界的问题。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reverseStr</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="o">!=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="mi">10</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">temp</span>
        <span class="n">a</span> <span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">2147483647</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">elif</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">res</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">214783648</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">res</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="mi">0</span>
<span class="k">print</span><span class="p">(</span><span class="n">reverseStr</span><span class="p">(</span><span class="o">-</span><span class="mi">123</span><span class="p">))</span>
</code></pre></div></div>

<p>收获：</p>

<blockquote>
  <p>返回一个结果，那先定义一个res=0</p>

  <p>先不判断一个数的正负，用abs(num)</p>

  <p>判断一个数是不是等于0，可以while(n)或者while(n!=0)</p>

  <p>取一个数的个位，可以与10取余，temp = num % 10</p>

  <p>一个数每回扩大10倍，可以乘以10再加上temp</p>

  <p>一个数去掉最后一位，可以除以10并向下取整int(num // 10)</p>

  <p>最后结果判断，有一个索引越界的问题</p>
</blockquote>

<h2 id="leetcode-09-回文数">LeetCode-09-回文数</h2>

<p><strong>题目：</strong></p>

<p>判断一个整数是否是回文数。 输入: 121  输出: true  输入: -121  输出: false  输入: 10  输出: false</p>

<p><strong>方法一：一位一位的取</strong></p>

<p>如果一个数是负数，那一定不是回文数。</p>

<p>先取绝对值，然后个位temp取余，数值num乘10相加，剩下的数a，除以10取整。</p>

<p>然后判断翻转过来的数和原来的数是不是一样的，联合和负数就一起判断了。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">num</span><span class="p">:</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">temp</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">res</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">print</span><span class="p">(</span><span class="n">isPalindrome</span><span class="p">(</span><span class="mi">121</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>判断条件可以正确的和大于零的数一起判断。</p>
</blockquote>

<p><strong>方法二：转化为字符串</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">isPalindrome</span><span class="p">(</span><span class="o">-</span><span class="mi">123</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>转化为list之后直接反转比较</p>
</blockquote>

<h1 id="字符串">字符串</h1>

<h2 id="出逃密码-listmap">出逃密码-list(map)</h2>

<p><strong>题目描述:</strong>
在一次密室逃脱中，玩家小玺需要通过对手给定的N组英文语句来推出密码，只有这样才能逃出，否则将会受到惩罚。N组英文语句中的单词分别用空格分隔，这里的单词是连续的、不是空格的单词。小玺需要输出每个语句中的单词数量来推出密码。请你编写程序帮助小玺快速找到出逃的密码。
<strong>输入描述:</strong>
输入第一行为英文语句的数量N
接下来每行为英文语句。
<strong>输出描述:</strong>
输出各英文语句中的单词数量，不同语句的数量用空格分隔。
<strong>样例输入:</strong>
2
“Hello my name is Xiaoxi”
“I can do it”
<strong>输出:</strong>
5 4</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">().</span><span class="n">strip</span><span class="p">())</span>
<span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">input</span><span class="p">().</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">())))))</span>
<span class="k">print</span><span class="p">(</span><span class="s">' '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>学到了list(map(function, str))的用法</p>
</blockquote>

<h2 id="leetcode-14-最长公共前缀">LeetCode-<a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h2>

<p><strong>题目：</strong></p>

<p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 <code class="language-plaintext highlighter-rouge">""</code>。</p>

<p>输入: [“flower”,”flow”,”flight”]  输出: “fl”</p>

<p>输入: [“dog”,”racecar”,”car”]  输出: “”</p>

<p><strong>思路一：</strong></p>

<p>一个一个字符的比较。先取出第一个词strs[0]，然后从strs[1:]第2个词开始一一比较，相等的话比较下一个，不相等直接返回strs[0][i]</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">longgestCommonPrefix</span><span class="p">(</span><span class="n">strs</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">strs</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">''</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="ow">or</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="n">longgestCommonPrefix</span><span class="p">([</span><span class="s">"flower"</span><span class="p">,</span> <span class="s">"flow"</span><span class="p">,</span> <span class="s">"flight"</span><span class="p">]))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>这道题相当于二维list了，一维是所有的单词，二维是比较所有单词的字母。</p>

<p>一维取第一个单词的长度来当索引下标了，因为要返回的是最长公共前缀。</p>

<p>二维就比较，得从第二个单词开始比较，当前单词的字母string[i]和第一个单词的字母strs[0] [i]是不是一样，</p>

<p>当出现不一样的时候就可以返回第一个单词的前几个字符strs[0] [:i]</p>

<p>遍历完了，都一样，那就是都是一样的前缀，就返回第一个单词。</p>

<p><strong>思路二：</strong></p>

<p>遍历strs里的每一个string，用set存储，看string[i]有几个值，只要一个的时候才加到result里，result+=sets.pop()，长度大于一个直接break，返回结果。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">longestCommonPrefix</span><span class="p">(</span><span class="n">strs</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s">''</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sets</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">string</span> <span class="ow">in</span> <span class="n">strs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">sets</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">print</span><span class="p">(</span><span class="n">longestCommonPrefix</span><span class="p">([</span><span class="s">"flower"</span><span class="p">,</span> <span class="s">"flow"</span><span class="p">,</span> <span class="s">"flight"</span><span class="p">]))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>集合的方法！</p>

<p>用set的列表生成式遍历每一个位置的字符set(string[i] for string in strs)，看长度是不是1</p>

<p>如果长度是1，那就把set集合里的字符pop()出来，加到res里！</p>

<p>否则的话就break退出，别忘了i+=1！</p>

<p>另外，因为写了个while True死循环，所以可以用try except来break跳出！</p>

<h2 id="leetcode-125-验证回文串">LeetCode-<a href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></h2>

<p><strong>题目：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入: "A man, a plan, a canal: Panama"   输出: true
输入: "race a car"    输出: false
</code></pre></div></div>

<p><strong>方法一</strong>：</p>

<p>最好的方法是有两个指针，一个指向头一个指向尾，每读一个往中间进一步，看是不是一样的，当走到中间或者右边的指针走到左边的时候，对比就完成了。</p>

<p>需要有while i &lt; j and not s[i].isalnum()这一行判断当前的s[i]是不是字母，因为会有空格和标点的存在！</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">isalnum</span><span class="p">():</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">isalnum</span><span class="p">():</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="k">print</span><span class="p">(</span><span class="n">isPalindrome</span><span class="p">(</span><span class="s">"A man, a plan, a canal: Panama"</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>两个指针首尾比较嘛。</p>

<p>直到找到第一个是字母的写法while i&gt;j and s[i].isalnum(): i += 1</p>

<p>直到找到最后一个是字母的写法while i&lt;j and s[j].isalnum():j-=1</p>

<p>然后进行比较，记得加.lower()</p>

<p>如果不相等直接返回false，否则的话i，j分别往里走一步然后继续比较。</p>

<h2 id="offer-05-替换空格"><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">Offer 05. 替换空格</a></h2>

<p><strong>题目：</strong></p>

<p>输入：s = “We are happy.”  输出：”We%20are%20happy.”</p>

<p><strong>思路一：</strong>直接遍历</p>

<p>新建字符串，遍历逐个相加，如果是空格就替换成%20，不是的话加到到新建的字符串后面</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">replaceSpace</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="s">''</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s">' '</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="s">'%20'</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">print</span><span class="p">(</span><span class="n">replaceSpace</span><span class="p">(</span><span class="s">"We are happy."</span><span class="p">))</span>
</code></pre></div></div>

<ul>
  <li>时间复杂度 O(N) ：遍历字符串。</li>
  <li>空间复杂度 O(N) ：字符串的长度。</li>
</ul>

<p><strong>思路二：</strong>join函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">replaceSpace</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">li</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">'%20'</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">li</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">replaceSpace</span><span class="p">(</span><span class="s">"We are happy."</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>思路三</strong>：replace函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">replaceSpace</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">' '</span><span class="p">,</span> <span class="s">'%20'</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">replaceSpace</span><span class="p">(</span><span class="s">"We are happy."</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="offer-58---i-翻转单词顺序-151-翻转字符串里的单词"><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">Offer-58 - I. 翻转单词顺序</a> <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 翻转字符串里的单词</a></h2>

<p><strong>题目：</strong></p>

<p>输入: “the sky is blue”   输出: “blue is sky the”    输入: “  hello world!  “   输出: “world! hello”   输入: “a good  example”   输出: “example good a”</p>

<p><strong>方法一：双指针</strong></p>

<p>算法解析：</p>

<ul>
  <li>倒序遍历字符串 s ，记录单词左右索引边界 i , j ；</li>
  <li>每确定一个单词的边界，则将其添加至单词列表 res ；</li>
  <li>最终，将单词列表拼接为字符串，并返回即可。</li>
</ul>

<p>复杂度分析：</p>

<ul>
  <li>时间复杂度 O(N) ： 其中 N 为字符串 s 的长度，线性遍历字符串。</li>
  <li>空间复杂度 O(N) ： 新建的 list(Python) 或     StringBuilder(Java) 中的字符串总长度 ≤N ，占用 O(N) 大小的额外空间。</li>
</ul>

<p><strong>思路一：双指针</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reverseWords</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">!=</span> <span class="s">' '</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span> <span class="s">' '</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="s">' '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">reverseWords</span><span class="p">(</span><span class="s">'the sky is blue'</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>逆序翻转字符串里的单词，那就倒着数每一个字符，只要不是空格，那就继续往前走，直到遇到空格位置。</p>

<p>用双指针，全指向字符串的末尾，用i，j来卡一个完整的单词。</p>

<p>找到空格以后就可以把i指针再往前走一个，然后给了j，作为新的字符串的末尾。</p>

<p><strong>思路二：用函数</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reverseWords</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">' '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">strip</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="k">print</span><span class="p">(</span><span class="n">reverseWords</span><span class="p">(</span><span class="s">'the sky is blue'</span><span class="p">))</span>
</code></pre></div></div>

<h1 id="字典">字典</h1>

<h2 id="递归找到所有id-name-递归">递归找到所有id name-递归</h2>

<p><strong>题目描述：</strong></p>

<p>输入一个字典，key有id，name，children，children是一个列表里面可能会有0个到多个的id，name，children字典
<strong>例子</strong>
{‘id’: 123, ’name’: ”123, ’children’: [
    {‘id’: 123, ’name’: ”123, ’children’: [
        {‘id’: 123, ’name’: ”123, ’children’: []},
        {‘id’: 123, ’name’: ”123, ’children’: []},
        {‘id’: 123, ’name’: ”123, ’children’: []},
        {‘id’: 123, ’name’: ”123, ’children’: []}
    ]},
    {‘id’: 123, ’name’: ”123, ’children’: []},
    {‘id’: 123, ’name’: ”123, ’children’: []},
    {‘id’: 123, ’name’: ”123, ’children’: []},
    {‘id’: 123, ’name’: ”123, ’children’: []}
]}
<strong>输出：</strong>
找到字典中的所有id name对
返回[(id, name), (id, name), (id, name), (id, name), (id, name)]</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input_dic</span> <span class="o">=</span> <span class="p">{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'123'</span><span class="p">,</span>
         <span class="s">'children'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'123'</span><span class="p">,</span>
                       <span class="s">'children'</span><span class="p">:</span> <span class="p">[{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'123'</span><span class="p">,</span> <span class="s">'children'</span><span class="p">:</span> <span class="p">[]},</span>
                                    <span class="p">{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'123'</span><span class="p">,</span> <span class="s">'children'</span><span class="p">:</span> <span class="p">[]},</span>
                                    <span class="p">{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'123'</span><span class="p">,</span> <span class="s">'children'</span><span class="p">:</span> <span class="p">[]},</span>
                                    <span class="p">{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'123'</span><span class="p">,</span> <span class="s">'children'</span><span class="p">:</span> <span class="p">[]}]},</span>
                      <span class="p">{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'123'</span><span class="p">,</span> <span class="s">'children'</span><span class="p">:</span> <span class="p">[]},</span>
                      <span class="p">{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'123'</span><span class="p">,</span> <span class="s">'children'</span><span class="p">:</span> <span class="p">[]},</span>
                      <span class="p">{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'123'</span><span class="p">,</span> <span class="s">'children'</span><span class="p">:</span> <span class="p">[]},</span>
                      <span class="p">{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'123'</span><span class="p">,</span> <span class="s">'children'</span><span class="p">:</span> <span class="p">[]}</span>
                      <span class="p">]}</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">getResult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">childrenList</span><span class="p">):</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">childrenList</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">childrenList</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">resultList</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">item</span><span class="p">[</span><span class="s">'id'</span><span class="p">],</span><span class="n">item</span><span class="p">[</span><span class="s">'name'</span><span class="p">]))</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">getResult</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s">'children'</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_dic</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">resultList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">getResult</span><span class="p">([</span><span class="n">input_dic</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">resultList</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">main</span><span class="p">(</span><span class="n">input_dic</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">main</span><span class="p">(</span><span class="n">input_dic</span><span class="p">)))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>学到了递归的写法和字典的取值</p>
</blockquote>

<h2 id="leetcode-13-罗马数字转整数">LeetCode-<a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h2>

<p>题目：</p>

<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>

<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。numral_map = {‘I’: 1, ‘V’: 5, ‘X’: 10, ‘L’: 50, ‘C’: 100, ‘D’: 500, ‘M’: 1000}</p>

<p>罗马数字 2 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</p>

<p>罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>

<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入: "III"   输出: 3   输入: "IV"   输出: 4   输入: "IX"    输出: 9   输入: "LVIII"   输出: 58   解释: L = 50, V= 5, III = 3.   输入: "MCMXCIV"   输出: 1994   解释: M = 1000, CM = 900, XC = 90, IV = 4.
</code></pre></div></div>

<p><strong>思路：</strong></p>

<p>“MCMXCIV”，如果后面的比前面的大，就认为是一对，值就是后面的减前面的，比如CM=1000-10，XC=100-10，要不然就是单个的。</p>

<p>最好的方法就是建立一个dictionary，把每一个symbol对应的value写到dictionary里面，</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">roman2Int</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">numral_map</span> <span class="o">=</span> <span class="p">{</span><span class="s">'I'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'V'</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s">'X'</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">'L'</span><span class="p">:</span> <span class="mi">50</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span> <span class="s">'D'</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span> <span class="s">'M'</span><span class="p">:</span> <span class="mi">1000</span><span class="p">}</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">numral_map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span> <span class="n">numral_map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">numral_map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numral_map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">numral_map</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">print</span><span class="p">(</span><span class="n">roman2Int</span><span class="p">(</span><span class="s">'IX'</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>根据下标给字符串里的每个字符绑定索引，然后再根据字典找到每个字符对应的数值！numral_map[s[i]]</p>

  <p>因为涉及到当前数与前面的一个数，所以索引下标得从if i&gt;0开始找起！</p>

  <p>然后就是公式的判断了，因为前边res已经加过了numral_map[s[i]]，所以当找到后边的数比前边的数大的时候就要res += numral_map[s[i]] - 2 * numral_map[s[i-1]]</p>
</blockquote>

<h2 id="leetcode-20-有效的括号-dicstackpop">LeetCode-20 有效的括号-dic[stack.pop()]</h2>

<p><strong>题目描述：</strong></p>

<p>输入: “()”  输出: true  输入: “()[]{}”  输出: true  输入: “(]”  输出: false  输入: “([)]”  输出: false  输入: “{[]}”  输出: true</p>

<p><strong>思路一：</strong></p>

<p>用栈，先入后出的特点，遍历括号，即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 stack 仍然为空；</p>

<p><strong>注意：</strong></p>

<ol>
  <li>
    <p>建立哈希表 dic 构建左右括号对应关系：key 左括号，value 右括号；这样查询 2 个括号是否对应只需 O(1) 时间复杂度；</p>
  </li>
  <li>
    <p>栈 stack 为空： 此时 stack.pop() 操作会报错；因此，我们采用一个取巧方法，给 stack 赋初值 ? ，并在哈希表 dic 中建立 key:’?’value:’?’key: ′?′，value: ′? ′的对应关系予以配合。</p>
  </li>
  <li>
    <p>此时当 stack 为空且 c 为右括号时，可以正常提前返回 false；</p>
  </li>
  <li>
    <p>字符串 s 以左括号结尾： 此情况下可以正常遍历完整个 s，但 stack 中遗留未出栈的左括号；因此，最后需返回 len(stack) == 1，以判断是否是有效的括号组合。</p>
  </li>
</ol>

<p>时间复杂度 O(N)：正确的括号组合需要遍历 1 遍 s；</p>

<p>空间复杂度 O(N)：哈希表和栈使用线性的空间大小。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="p">{</span><span class="s">'{'</span><span class="p">:</span> <span class="s">'}'</span><span class="p">,</span>  <span class="s">'['</span><span class="p">:</span> <span class="s">']'</span><span class="p">,</span> <span class="s">'('</span><span class="p">:</span> <span class="s">')'</span><span class="p">,</span> <span class="s">'?'</span><span class="p">:</span> <span class="s">'?'</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">dic</span><span class="p">[</span><span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()]</span> <span class="o">!=</span> <span class="n">c</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">print</span><span class="p">(</span><span class="n">isValid</span><span class="p">(</span><span class="s">"()(]{}"</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>学到了字典弹出一个数据是dic[strack.pop()]</p>
</blockquote>

<h2 id="offer-50-第一个只出现一次的字符"><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">Offer-50. 第一个只出现一次的字符</a></h2>

<p><strong>题目：</strong></p>

<p>s = “abaccdeff”   返回 “b”</p>

<p>s = “”   返回 “ “</p>

<p><strong>思路1：</strong></p>

<p>1：哈希表</p>

<p>\1.   先遍历字符串 s ，统计各字符数量是否 &gt; 1，dic[c] = not c in dic，dic = {‘a’: False, ‘b’: True, ‘c’: False, ‘d’: True, ‘e’: True, ‘f’: False}</p>

<p>\2.   再遍历字符串 s ，在哈希表中找到首个 “数量为 1 的字符”，并返回，if dic[c]，c</p>

<p>复杂度分析：</p>

<ul>
  <li>时间复杂度 O(N) ： N 为字符串 s 的长度；需遍历 s 两轮，使用 O(N) ；HashMap 查找操作的复杂度为 O(1) ；</li>
  <li>空间复杂度 O(1) ： 由于题目指出 s 只包含小写字母，因此最多有 26 个不同字符，HashMap 存储需占用 O(26) = O(1) 的额外空间。</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">firstUniqChar</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dic</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dic</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">c</span>
    <span class="k">return</span> <span class="s">''</span>

<span class="k">print</span><span class="p">(</span><span class="n">firstUniqChar</span><span class="p">(</span><span class="s">'anaccdeff'</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>键值对是字符：在不在字典中出现可以是dic[c] = not c in dic</p>

<p>如果出现，可以是if dic[c]:</p>

<p><strong>思路2：</strong></p>

<p>相比于方法一，方法二减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，方法二则效率更高。</p>

<p>时间和空间复杂度均与 “方法一” 相同，而具体分析：方法一 需遍历 s 两轮；方法二 遍历 s 一轮，遍历 dic 一轮（ dic 的长度不大于 26 ）。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="k">def</span> <span class="nf">firstUniqChar</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">dic</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">dic</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">dic</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">k</span>
    <span class="k">return</span> <span class="s">''</span>
<span class="k">print</span><span class="p">(</span><span class="n">firstUniqChar</span><span class="p">(</span><span class="s">'anaccdeff'</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>orderdic的使用</p>

<h1 id="列表">列表</h1>

<h2 id="期末快速阅卷-异或-eval">期末快速阅卷-异或^ eval</h2>

<p><strong>题目描述:</strong>
每到期末考完试，同学们就会迎来寒/暑假:但者师们却忙得不可开交，大量的阅卷工作让者师们身心俱疲。现在老师们想到了一个快速阅卷的方法:先给定两个答案(一个是正确答案，另一个是学生试卷上的答案)，两个答案的顺序是一对应的。请你编写-个程序， 帮助者师们快速检验两个答案是否一致。若答案一致输出itrue, 否则输出false.
<strong>输入描述：</strong>
第一行输入者师给定的正确答案;
第二行输入学生的答案。
<strong>输出描述：</strong>
若答案完全致输出true, 否则输出false.
<strong>样例输入：</strong>
[1,2,3]
[1,2,3]
<strong>样例输出：</strong>
true
<strong>知识点：</strong>
eval() 函数用来执行一个字符串表达式，并返回表达式的值。</p>

<blockquote>
  <p>x = 7
eval( ‘3 * x’ )
21
eval(‘pow(2,2)’)
4
eval(‘2 + 2’)
4
n=81
eval(“n + 4”)
85</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">answer</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">input</span><span class="p">().</span><span class="n">strip</span><span class="p">())</span>
<span class="n">student</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">input</span><span class="p">().</span><span class="n">strip</span><span class="p">())</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">answer</span><span class="p">,</span> <span class="n">student</span><span class="p">):</span>
<span class="k">if</span> <span class="n">i</span> <span class="o">^</span> <span class="n">j</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
<span class="k">print</span><span class="p">(</span><span class="s">'false'</span><span class="p">)</span>
<span class="nb">exit</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'true'</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>学到了eval()的用法</p>

  <p>以及判断两个数不一样用i^j != 0</p>
</blockquote>

<h2 id="优先理发-sorted-lambda">优先理发-sorted, lambda</h2>

<p><strong>题目描述:</strong>
某大学的志愿者团队每个月部会去养老院为老人们理发。在毒理发老人的名单中，志愿吉得知有n位老人需要理发。根据惯例，应优先女性理发，且优先年龄最大的老人理发(不管年龄多大，只要是女性就会比男性优先理发)。请你根据名单中老人的性别和年龄，为志愿者排出最科学的理发顺序。
<strong>输入描述：</strong>
第一行为需理发老人的编号;
第二行为老人的性别，女性=1,男性=O;
第三行为老人的年龄n (ns1s100)↓用空格分隔:需要注意者人的性别和年龄按数字顺序是对应的
<strong>输出描述：</strong>
输出理发的顺序(即需理发老人的编号，且每个老人的编号用空档隔开)
<strong>样例输入：</strong>
1 2 3 4 5
1 0 1 0 1
65 67 87 76 98
<strong>样例输出：</strong>
5 3 1 4 2</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">genders</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">ages</span> <span class="o">=</span> <span class="p">[</span><span class="mi">65</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">87</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">98</span><span class="p">]</span>
<span class="c1"># orders = list(map(int,input().split()))
# genders = list(map(int,input().split()))
# ages = list(map(int,input().split()))
</span><span class="n">womens</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">mans</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">order</span><span class="p">,</span> <span class="n">gender</span><span class="p">,</span> <span class="n">age</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">orders</span><span class="p">,</span> <span class="n">genders</span><span class="p">,</span> <span class="n">ages</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">gender</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">womens</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">order</span><span class="p">,</span> <span class="n">age</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mans</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">order</span><span class="p">,</span> <span class="n">age</span><span class="p">])</span>
<span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">womens</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mans</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="k">print</span><span class="p">(</span><span class="s">" "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>学到了通过zip给数据分类为women和men</p>

  <p>还有sorted排序返回一个新list，传list和其他关键字</p>

  <p>以及lambda args:表达式的用法</p>
</blockquote>

<h2 id="leetcode-26-删除排序数组中的重复项-原地修改数组">LeetCode-26-删除排序数组中的重复项-原地修改数组</h2>

<p><strong>题目：</strong></p>

<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，原地修改，O(1) 的复杂度。nums = [1,1,2]，函数应该返回 2, 原数组为 1, 2。 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回5, 并且原数组为 0, 1, 2, 3, 4。</p>

<p><strong>方法一：</strong></p>

<p>如果nums没有数据直接返回0，</p>

<p>否则的话设计一个记录有多少个不同数据的count值=0，</p>

<p>然后循环nums里的每一个数据，len(nums)</p>

<p>li[count]数组是从前往后有序排列的第1 2 3 4 5个数，li[i]是真实的那个数</p>

<p>找到实际li[i]的数与第一个数li[count]不相等的时候，然后把值赋给li[count]，count的数值就要加1，</p>

<p>最后返回count+1，count不能是1，因为假如nums=[1]的话，nums[count]就会报错，out of range</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">deldup</span><span class="p">(</span><span class="n">li</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">li</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">li</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">li</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">li</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">!=</span> <span class="n">li</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">li</span><span class="p">[</span><span class="n">count</span><span class="p">]</span> <span class="o">=</span> <span class="n">li</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">deldup</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>学到了用count=0记录一个新list，逐个1 2 3 4 5，在原数组上直接操作数据</p>
</blockquote>

<h2 id="leetcode-27-移除元素">LeetCode-27-移除元素</h2>

<p><strong>题目：</strong></p>

<p>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不使用额外数组空间，O(1)原地修改输入数组。
 nums = [3,2,2,3], val = 3，函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
 nums = [0,1,2,2,3,0,4,2], val = 2，函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>

<p><strong>思路：</strong></p>

<p>双指针，一个指在array的开始，一个指在array的结束，当i&lt;=last的时候，进行换。</p>

<p>如果当前值nums[i]==给定的val值，那么当前值跟最后一个值换一下，怎么删除最后一位呢？last指针前移，这不是真正意义上的删除元素，</p>

<p>否则的话，就是我们不需要删除的，那就指针后移，i+1，最后返回last+1</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">removeElement</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">last</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">last</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">last</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">last</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">removeElement</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>让原地修改，那就不能初始化空list=[]，所以想双指针方法，换。</p>

<p>那就遍历列表吧，如果当前数==val那个数nums[i]==val，就和最后一个数换一下，然后删除(前移)一位，last-=1，</p>

<p>如果不相等，那指针后移，i+1</p>

<p>最后返回last+1，也就是删除元素之后的列表的长度。</p>

<h2 id="leetcode-35-搜索插入位置">LeetCode-35-搜索插入位置</h2>

<p><strong>题目：</strong></p>

<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
 输入: [1,3,5,6], 5  输出: 2  输入: [1,3,5,6], 2  输出: 1  输入: [1,3,5,6], 7  输出: 4  输入: [1,3,5,6], 0  输出: 0</p>

<p><strong>思路：</strong></p>

<p>如果target在array中，就返回index，不在的话返回nums[i]&gt;target所在的index。</p>

<p>为了节省空间，先判断target是不是大于array最大的数，要是的话，直接返回array的长度len(array)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">searchInsert</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>

<span class="k">print</span><span class="p">(</span><span class="n">searchInsert</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">7</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>因为是排序数组，所以为了节省空间，先看看最后一个数和目标值的大小比较，如果小的话，直接返回数组长度就可以了。</p>

<p>接下来就可以通过下标遍历nums，找到nums[i] &gt;= val目标值的i，返回就行了。</p>

<h2 id="leetcode-66-加一">LeetCode-66-加一</h2>

<p><strong>题目：</strong></p>

<p>输入: [1,2,3]  输出: [1,2,4]
 输入: [4,3,2,1]  输出: [4,3,2,2]</p>

<p><strong>思路：</strong></p>

<p>直接从最后一位数起，如果是9，那就置为0，如果不是9，就是+1返回，</p>

<p>如果遍历完了全都是9，那就手动把第一个变为1，然后结尾再添加一个0，注意添加的位置是在for循环结束以后。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">plusOne</span><span class="p">(</span><span class="n">digits</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="p">))):</span>
        <span class="k">if</span> <span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">digits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">digits</span>
    <span class="n">digits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">digits</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">digits</span>
        
<span class="k">print</span><span class="p">(</span><span class="n">plusOne</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">]))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>倒着遍历list，reversed(range(len(digits)))</p>

<p>还有，分两种情况，要有2个return。</p>

<h2 id="leetcode-88-合并两个有序数组">LeetCode-<a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2>

<p><strong>题目：</strong></p>

<p>nums1 = [1,2,3,0,0,0], m = 3</p>

<p>nums2 = [2,5,6],    n = 3</p>

<p>输出: [1,2,2,3,5,6]</p>

<p>思路：</p>

<p>从后往前合并。</p>

<p>nums1[m-1]是第一个list除0外最后一个数，</p>

<p>nums2[n-1]是第二个list最后一个数，</p>

<p>nums1[m+n-1]是第一个list最后一个数</p>

<p>比较大小，如果是第二个list的数比较大，那就把它放到第一个list最后的位置，然后第二个list的指针前移，</p>

<p>否则的话第一个list最后一个数与最后一位的数换一下，然后第一个list的指针前移，</p>

<p>一直循环，直到第一个list遍历完，m=0，然后剩下的前n个数复制到第一个list里。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">nums1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">nums2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">m</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nums1</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums2</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">nums1</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nums1</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nums1</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums1</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">nums1</span><span class="p">[</span><span class="n">m</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">m</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nums1</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums2</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">nums1</span>

<span class="k">print</span><span class="p">(</span><span class="n">merge</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>思路还是挺清晰的，明确三个变量是什么</p>

<p>nums1[m-1]是第一个list除0外最后一个数，</p>

<p>nums2[n-1]是第二个list最后一个数，</p>

<p>nums1[m+n-1]是第一个list最后一个数</p>

<p>然后比较大小，第一个list是换，第二个list是放置，</p>

<p>最后别忘了剩下的数要复制到前边去。</p>

<h2 id="leetcode-118杨辉三角-dp">LeetCode-118杨辉三角-dp</h2>

<p><strong>题目：</strong></p>

<p>给定一个非负整数 numRows，生成杨辉三角的前 <em>numRows</em> 行。</p>

<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>

<p><strong>示例：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</code></pre></div></div>

<p><strong>方法一：</strong></p>

<p>最简单的方法就是把每一行的数都generate出来，进行重复的套路，如果是首尾，那就是1，如果不是，那第i个数就是i-1行j-1的值和j的值相加之和</p>

<p>首先是一个空的result，然后每一行把生成的结果append到result里面去，要有多少行呢？就是numRows</p>

<p>首先先添加一个空的[]，然后再来一个循环，for j in range(i+1)，第一行有一个元素，第二行有两个元素，第三行有三个元素，…</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">triangle</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>  <span class="c1"># 如果是这一行的首或者尾，也就是0和i
</span>                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="k">print</span><span class="p">(</span><span class="n">triangle</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">triangle</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dp</span> 
<span class="k">print</span><span class="p">(</span><span class="n">triangle</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>方法一学到了判断一个数是list的首尾是if j in (0,i)</p>

  <p>以及二维数组里对数据更改是result[i][]再取值。</p>

  <p>方法二学会了先设置一个dp矩阵，然后再动态的更改里面的数据，注意索引的范围</p>
</blockquote>

<h2 id="leetcode-121-买卖股票的最佳时机">LeetCode-<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2>

<p><strong>题目：</strong></p>

<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格，设计一个算法来计算你所能获取的最大利润。</p>

<p>输入: [7,1,5,3,6,4]  输出: 5  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p>

<p>输入: [7,6,4,3,1]   输出: 0  解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>

<p><strong>思路：</strong></p>

<p>需要找到一个最好的卖出点：</p>

<p>即当前价格和最小价格差值是最大的时候，max(max_profit, price-min_price)，</p>

<p>用min(min_price, price)来记录每一轮的最小价格是多少，</p>

<p>用max(max_profit, price-min_price)，来记录最大差值是多少。</p>

<p>最后返回预先定义好的max_profit。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
    <span class="n">max_profit</span><span class="p">,</span> <span class="n">min_price</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s">'inf'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">price</span> <span class="ow">in</span> <span class="n">prices</span><span class="p">:</span>
        <span class="n">min_price</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">price</span><span class="p">,</span> <span class="n">min_price</span><span class="p">)</span>
        <span class="n">max_profit</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_profit</span><span class="p">,</span> <span class="n">price</span><span class="o">-</span><span class="n">min_price</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">max_profit</span>

<span class="k">print</span><span class="p">(</span><span class="n">maxProfit</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>一个无穷大的数可以用float(“inf”)表示，</p>

<p>找到数组里最小的数可以用min(price, min_price)来比较，</p>

<p>找到差值最大的数可以用max(max_prifit, price-min_price)来找到</p>

<h2 id="leetcode-122-买卖股票的最佳时机-ii">LeetCode-<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2>

<p><strong>题目：</strong></p>

<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>

<p>输入: [7,1,5,3,6,4]  输出: 7  解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>

<p>输入: [1,2,3,4,5]   输出: 4  解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</p>

<p>输入: [7,6,4,3,1]   输出: 0  解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p>

<p><strong>思路：</strong></p>

<p>如果后面的数要是比前面的数大，就把差值加到total里。</p>

<p>可以用if prices[i] &gt; prices[i-1]: total += prices[i]-prices[i-1]，得注意range是从range(1,len(prices)) 1开始的。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total</span>

<span class="k">print</span><span class="p">(</span><span class="n">maxProfit</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>和思路一样，如果后面的数要是比前面的数大，就把差值加到total里。可以用if prices[i] &gt; prices[i-1]: total += prices[i]-prices[i-1]表示。</p>

<h2 id="leetcode-136-只出现一次的数字">LeetCode-<a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h2>

<p><strong>题目：</strong></p>

<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>

<p>输入: [2,2,1]  输出: 1  输入: [4,1,2,1,2]  输出: 4</p>

<p><strong>思路：</strong></p>

<p>异或。两个相同的会是0，其余与0做异或是其本身，这样异或nums里的所有的数字，依次类推，单个的那个会留下来。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">singleNumber</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">^=</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">print</span><span class="p">(</span><span class="n">singleNumber</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>异或，两个相同的数异或会是0，遍历一遍数组，单个的那个数会留下来。</p>

<h2 id="剑指-offer-04-二维数组中的查找"><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h2>

<p><strong>题目：</strong></p>

<p>输入一个二维数组和一个整数，判断数组中是否含有该整数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[
 [1,  4, 7, 11, 15],
 [2,  5, 8, 12, 19],
 [3,  6, 9, 16, 22],
 [10, 13, 14, 17, 24],
 [18, 21, 23, 26, 30]
]
</code></pre></div></div>

<p><strong>思路：左下角定位法</strong></p>

<p>定位左下角，按照行列索引确定matrix中的数字，</p>

<p>起始行列i，j行列坐标分别为左下角的len(matirx)-1和0，</p>

<p>然后开始循环，行索引i要逐渐的减小，直到i&gt;=0，列索引要逐渐的增大，直到j&lt;len(matix[0])，</p>

<p>判断matrix中的数字[i] [j]与要找的数字大小的关系，进行行列索引的++–，找到了返回True，没有找到，出了循环返回False。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findNumberIn2DArray</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
    
<span class="k">print</span><span class="p">(</span><span class="n">findNumberIn2DArray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">15</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">19</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">22</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">24</span><span class="p">],[</span><span class="mi">18</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">30</span><span class="p">]],</span><span class="mi">16</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>左下角可以用len(matrix)-1, 0来表示，</p>

<p>循环的判断条件是<em>while</em> i&gt;=0 and j &lt; len(<em>matrix</em>)-1:</p>

<p>如果左下角数&gt;target，那就行－1，</p>

<p>若果左下角数&lt;target，那就列+1，</p>

<p>找到返回true，没找到返回false。</p>

<ul>
  <li>时间复杂度 O(M+N) ：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N次。</li>
  <li>空间复杂度 O(1) : i, j 指针使用常数大小额外空间。</li>
</ul>

<h2 id="offer-10--ii-青蛙跳台阶问题-dp"><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">Offer 10- II. 青蛙跳台阶问题</a>-dp</h2>

<p><strong>题目：</strong></p>

<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>

<p>输入：n = 2   输出：2</p>

<p>输入：n = 7   输出：21</p>

<p>输入：n = 0   输出：1</p>

<p><strong>思路：动态规划</strong></p>

<p>此类求 多少种可能性 的题目一般都有 递推性质 ，即 f(n) 和 f(n-1)…f(1)之间是有联系的。</p>

<ul>
  <li>
    <p>设跳上 n 级台阶有     f(n)种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上     1 级或 2 级台阶。</p>
  </li>
  <li>
    <ul>
      <li>当为 1 级台阶： 剩 n-1 个台阶，此情况共有 f(n-1)种跳法；</li>
      <li>当为 2 级台阶： 剩 n-2 个台阶，此情况共有 f(n-2)种跳法。</li>
    </ul>
  </li>
  <li>
    <p>f(n)为以上两种情况之和，即 f(n)=f(n-1)+f(n-2) ，以上递推性质为斐波那契数列。本题可转化为 求斐波那契数列第 n 项的值 ，与 面试题10-     I. 斐波那契数列 等价，唯一的不同在于起始数字不同。</p>
  </li>
  <li>
    <ul>
      <li>青蛙跳台阶问题： f(0)=1 , f(1)=1 , f(2)=2；</li>
      <li>斐波那契数列问题： f(0)=0 , f(1)=1 , f(2)=1 。</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stairs</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stairs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">stairs</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">stairs</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="c1"># 这样递归可以，但是复杂度太高，可以原地修改
</span>
<span class="k">def</span> <span class="nf">staris</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f1</span> <span class="o">+</span> <span class="n">f2</span>
    <span class="k">return</span> <span class="n">f1</span>
<span class="k">print</span><span class="p">(</span><span class="n">stairs</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>动态规划法就是比较节省空间</p>
</blockquote>

<h2 id="offer-11-旋转数组的最小数字"><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">Offer-11. 旋转数组的最小数字</a></h2>

<p><strong>题目：</strong></p>

<p>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p>

<p>输入：[3,4,5,1,2]   输出：1   输入：[2,2,2,0,1]   输出：0</p>

<p><strong>思路：二分法</strong></p>

<p>二分法 解决，其可将 遍历法 的 线性级别 时间复杂度降低至 对数级别。</p>

<ul>
  <li>
    <p>初始化： 声明     i, j 双指针分别指向 nums数组左右两端；</p>
  </li>
  <li>
    <p>循环二分： 设     m = (i + j) / 2为每次二分的中点（ “/” 代表向下取整除法，因此恒有 i≤m&lt;j ），可分为以下三种情况：</p>
  </li>
  <li>
    <ul>
      <li>当 nums[m] &gt; nums[j] 时： m 一定在 左排序数组 中，即旋转点 x 一定在      [m+1,j] 闭区间内，因此执行i=m+1；</li>
      <li>当 nums[m]&lt;nums[j] 时： m 一定在 右排序数组 中，即旋转点 x 一定在[i,m]      闭区间内，因此执行j=m；</li>
      <li>当 nums[m]=nums[j] 时： 无法判断      m 在哪个排序数组中，即无法判断旋转点 x 在      [i,m] 还是[m+1,j] 区间中。解决方案： 执行j=j−1 缩小判断范围，分析见下文。</li>
    </ul>
  </li>
  <li>返回值： 当i=j时跳出二分循环，并返回旋转点的值nums[i] 即可。</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">minArray</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">numbers</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">numbers</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="n">minArray</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>取中间的那个数 (i+j) // 2，而且是向下取整
  通过比较中间的数值大小和最右边数的大小判断最小值在哪个区间
  最后通过减小j-=1来缩小范围</p>
</blockquote>

<h2 id="offer-17-打印从1到最大的n位数"><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">Offer-17. 打印从1到最大的n位数</a></h2>

<p><strong>题目：</strong></p>

<p>比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>

<p>输入: n = 1   输出: [1,2,3,4,5,6,7,8,9]</p>

<p><strong>思路：</strong></p>

<p>最大的 1 位数是 9 ，最大的 2 位数是 99 ，最大的 3 位数是 999 。则可推出公式：end = 10^n - 1</p>

<p>那么遍历每一个数存到res里就可以了！</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">printnums</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">n</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">printnums</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>学到了一个数的多少次方是，10 ** n</p>
</blockquote>

<h2 id="offer-21-调整数组顺序使奇数位于偶数前面"><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">Offer-21. 调整数组顺序使奇数位于偶数前面</a></h2>

<p><strong>题目：</strong></p>

<p>输入：nums = [1,2,3,4]   输出：[1,3,2,4] or [3,1,2,4] √</p>

<p><strong>思路：</strong></p>

<p>双指针，换，判断一个数是否是奇数可以num&amp;1==1来判断。</p>

<ol>
  <li>
    <p>指针 i 从左向右寻找偶数；</p>
  </li>
  <li>
    <p>指针 j 从右向左寻找奇数；</p>
  </li>
  <li>
    <p>将 偶数 nums[i] 和 奇数 nums[j] 交换。</p>
  </li>
</ol>

<ul>
  <li>
    <p>复杂度分析：</p>
  </li>
  <li>
    <ul>
      <li>时间复杂度 O(N) ：      N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。</li>
      <li>空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exchange</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">nums</span>
<span class="k">print</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<blockquote>
  <p>学会了判断奇偶数用 &amp; 1
  奇数 &amp; 1 = 1
  偶数 &amp; 1 = 0</p>
</blockquote>

<h2 id="offer-29-顺时针打印矩阵-54-螺旋矩阵"><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">Offer-29. 顺时针打印矩阵</a> <a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h2>

<p><strong>题目：</strong></p>

<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]    输出：[1,2,3,6,9,8,7,4,5]</p>

<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]   输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>

<p>解题思路：</p>

<p>根据题目示例 matrix = [[1,2,3],[4,5,6],[7,8,9]] 的对应输出 [1,2,3,6,9,8,7,4,5] 可以发现，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。</p>

<p>复杂度分析：</p>

<ul>
  <li>
    <p>时间复杂度 O(MN) ： M, N分别为矩阵行数和列数。</p>
  </li>
  <li>
    <p>空间复杂度 O(1)： 四个边界 l , r , t , b 使用常数大小的 额外 空间（ res 为必须使用的空间）。</p>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">spiralOrder</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">matrix</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> 
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="c1"># left to right                 
</span>        <span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span> 
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> 
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">r</span><span class="p">])</span> <span class="c1"># top to bottom                 
</span>        <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span> 
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> 
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="c1"># right to left                 
</span>        <span class="n">b</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">:</span> 
            <span class="k">break</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">t</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> 
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">l</span><span class="p">])</span> <span class="c1"># bottom to top                 
</span>        <span class="n">l</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span> 
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">res</span>
    
<span class="k">print</span><span class="p">(</span><span class="n">spiralOrder</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]]))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>好绕，没仔细看~，没用代码的语言梳理语言。</p>

<p><strong>思路2：</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<h2 id="offer-40最小的k个数"><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">Offer-40.最小的k个数</a></h2>

<p><strong>题目：</strong></p>

<p>输入：arr = [3,2,1], k = 2  输出：[1,2] 或者 [2,1]</p>

<p>输入：arr = [0,1,2,1], k = 1   输出：[0]</p>

<ul>
  <li>
    <p>基础排序算法总结</p>
  </li>
  <li>
    <ul>
      <li>交换类：冒泡排序、快速排序</li>
      <li>选择类：简单选择排序、快速排序</li>
      <li>插入类：直接插入排序、shell 排序</li>
      <li>归并类：归并排序</li>
    </ul>
  </li>
</ul>

<h3 id="1-交换类排序--冒泡排序">1. 交换类排序 – 冒泡排序√</h3>

<ul>
  <li>思想：从无序序列头部开始，进行两两比较，根据大小交换位置，直到最后将最大（小）的数据元素交换到了无序队列的队尾，从而成为有序序列的一部分；下一次继续这个过程，直到所有数据元素都排好序。</li>
  <li>时间复杂度：O(n2),空间复杂度 O(1)</li>
  <li>稳定性： 稳定</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">nums</span>
        <span class="k">return</span> <span class="n">nums</span>
    <span class="k">def</span> <span class="nf">getLeastNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">bubble_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)[:</span><span class="n">k</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">getLeastNumbers</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>写类方法，可以直接self.swap调用，而且不用写self</p>

<p>设置一个flag来设置是不是要交换</p>

<p>第一层for循环是range(1,len(nums))，因为是从第二个数字开始比较的。</p>

<p>第二层for循环是range(0,len(nums)-i)，是做了优化。</p>

<p>还有就是主函数getLeastNumbers那里，学习一下初试条件判断。</p>

<h3 id="2-交换类排序--快速排序">2. 交换类排序 – 快速排序√</h3>

<ul>
  <li>思想：分别从初始序列“6 1 2 7 9 3 4 5 10     8”两端开始“探测”。先从右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换他们。这里可以用两个变量 i 和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和“哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 i=1），指向数字 6。让哨兵 j 指向序列的最右边（即 j=10），指向数字 8。</li>
  <li>
    <p>每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。</p>
  </li>
  <li>时间复杂度：O(nlogn),空间复杂度 O(nlogn)</li>
  <li>稳定性： 不稳定</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">pivot</span><span class="p">]:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">pivot</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">partition</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">quick_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">pivot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">quick_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getLeastNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">quick_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">getLeastNumbers</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="3-选择类排序--简单选择排序">3. 选择类排序 – 简单选择排序</h3>

<ul>
  <li>思想：每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止</li>
  <li>时间复杂度：O(n2),空间复杂度 O(1)</li>
  <li>稳定性： 不稳定</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># 循环迭代地将后面未排序序列最小值交换到前面有序序列末尾
</span>    <span class="k">def</span> <span class="nf">select_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">min_index</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">min_index</span><span class="p">]:</span>
                    <span class="n">min_index</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">if</span> <span class="n">min_index</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">min_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nums</span>

    <span class="k">def</span> <span class="nf">getLeastNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">select_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)[:</span><span class="n">k</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">getLeastNumbers</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="4-选择类排序--堆排序">4. 选择类排序 – 堆排序</h3>

<ul>
  <li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">思想</a>：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了</li>
  <li>时间复杂度：O(nlogn),空间复杂度 O(1)</li>
  <li>稳定性： 不稳定</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">heapify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="n">largest</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">largest</span><span class="p">]:</span>
            <span class="n">largest</span> <span class="o">=</span> <span class="n">right</span>
        <span class="k">if</span> <span class="n">largest</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">largest</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">largest</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build_heap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="c1"># 从最后一个非叶子节点开始堆化
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getLeastNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>
        <span class="n">heap</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">build_heap</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">heap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">heapify</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">heap</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">getLeastNumbers</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="5-插入类排序--直接插入排序">5. 插入类排序 – 直接插入排序</h3>

<ul>
  <li>思想：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</li>
  <li>时间复杂度：O(n2),空间复杂度 O(1)</li>
  <li>稳定性： 不稳定</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">insert_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
            <span class="n">cur_value</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">while</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cur_value</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_value</span>
        <span class="k">return</span> <span class="n">nums</span>

    <span class="k">def</span> <span class="nf">getLeastNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">insert_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)[:</span><span class="n">k</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">getLeastNumbers</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="6-插入类排序--shell-排序">6. 插入类排序 – shell 排序</h3>

<ul>
  <li><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">思想</a>：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</li>
  <li>时间复杂度：O(n1.3),空间复杂度 O(1)</li>
  <li>稳定性： 不稳定</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="c1"># 分组插入排序
</span>    <span class="k">def</span> <span class="nf">insert_sort_gap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">gap</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">gap</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">),</span> <span class="n">gap</span><span class="p">):</span>
            <span class="n">cur_value</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">while</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">gap</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="n">gap</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cur_value</span><span class="p">:</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="n">gap</span><span class="p">]</span>
                <span class="n">pos</span> <span class="o">-=</span> <span class="n">gap</span>
            <span class="n">nums</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_value</span>

    <span class="k">def</span> <span class="nf">shell_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="n">gap</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="n">gap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gap</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">insert_sort_gap</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gap</span><span class="p">)</span>
            <span class="n">gap</span> <span class="o">//=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">nums</span>

    <span class="k">def</span> <span class="nf">getLeastNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">shell_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)[:</span><span class="n">k</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">getLeastNumbers</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="7-归并类排序--归并排序">7. 归并类排序 – 归并排序√</h3>

<ul>
  <li><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">思想</a>：归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</li>
  <li>时间复杂度：O(nlogn),空间复杂度 O(1)</li>
  <li>稳定性： 不稳定</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">l2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">l2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">l1</span><span class="p">):</span>
            <span class="n">res</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l2</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l1</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nums</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">merge_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">merge_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getLeastNumbers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">merge_sort</span><span class="p">(</span><span class="n">arr</span><span class="p">)[:</span><span class="n">k</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">Solution</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">getLeastNumbers</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="offer-53---i-在排序数组中查找数字-i"><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">Offer-53 - I. 在排序数组中查找数字 I</a></h2>

<p><strong>题目：</strong></p>

<p>统计一个数字在排序数组中出现的次数。</p>

<p>输入: nums = [5,7,7,8,8,10], target = 8   输出: 2   输入: nums = [5,7,7,8,8,10], target = 6   输出: 0</p>

<p><strong>思路：</strong></p>

<p>排序数组中的搜索问题，首先想到 二分法 解决。</p>

<p>所有数字target形成一个窗口，使用二分法分别找到左边界left和右边界right ，易得数字target的数量为right - left - 1。</p>

<p><strong>复杂度分析：</strong></p>

<p>时间复杂度 O(log N)： 二分法为对数级别复杂度。</p>

<p>空间复杂度 O(1)： 几个变量使用常数大小的额外空间。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
     <span class="c1"># 搜索右边界 right         
</span>    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">i</span>
    <span class="c1"># 若数组中无 target ，则提前返回         
</span>    <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">target</span><span class="p">:</span> 
        <span class="k">return</span> <span class="mi">0</span>
    <span class="c1"># 搜索左边界 left         
</span>    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">j</span>
    <span class="k">return</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span>

<span class="k">print</span><span class="p">(</span><span class="n">search</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="mi">8</span><span class="p">))</span>
</code></pre></div></div>

<p>二分法还没想明白😓</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">不用二分法</span><span class="err">，</span><span class="n">最直接的想法</span>
<span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">res</span>
<span class="k">print</span><span class="p">(</span><span class="n">search</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span><span class="mi">8</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="offer-53---ii-0n-1中缺失的数字"><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">Offer 53 - II. 0～n-1中缺失的数字</a></h2>

<p><strong>题目：</strong></p>

<p>输入: [0,1,3]  输出: 2   输入: [0,1,2,3,4,5,6,7,9]   输出: 8</p>

<p><strong>思路：</strong></p>

<p>二分法解决。</p>

<p>左子数组： nums[i] = i ；</p>

<p>右子数组： nums[i] ≠ i；</p>

<p>缺失的数字等于 “右子数组的首位元素” 对应的索引；</p>

<p><strong>复杂度分析：</strong></p>

<p>时间复杂度 O(log N)： 二分法为对数级别复杂度。</p>

<p>空间复杂度 O(1)： 几个变量使用常数大小的额外空间。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">missingNumber</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">==</span><span class="n">m</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">i</span>

<span class="k">print</span><span class="p">(</span><span class="n">missingNumber</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]))</span>
</code></pre></div></div>

<p><strong>收获：</strong></p>

<p>if nums[m]==m，就是说下标上的数等于下标。</p>

<p>如果相等，就说明缺失的数还在右边，那i 就往右走一步，否则的话，j就往左走一步。</p>

<p>另外要注意，双指针，取中间值的时候，m=int(i+j)//2一定要写在while i&lt;j 的循环里，要不然中间指针没有更新会陷入死循环。</p>
:ET