I"<h1 id="new创建对象的过程发生了什么"><a href="https://alexzhong22c.github.io/2017/08/12/js-new-happen/">new创建对象的过程发生了什么</a></h1>

<p>用面向对象语言们通用的观点来看：new 是用来实例化一个类，从而在内存中分配一个实例对象。</p>

<p>我们通过一个例子来讨论<strong>new的过程中发生了什么</strong> ：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function Person(name) {
    this.name = name;
}
Person.hairColor = "black";
Person.prototype.say = function() {
    console.log("My name is " + this.name);
};
var john = new Person("John");

console.log(
	john.name, // "John",
  	john.hairColor, // undefined
  	john.height // undefined
);
john.say(); // "My name is John"

console.log(
	Person.name, // "Person"
  	Person.hairColor // "black"
);
Person.say(); // Person.say is not a function
</code></pre></div></div>

<h2 id="重点解析">重点解析</h2>

<p>第8行代码是关键：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var john = new Person("John");
</code></pre></div></div>

<p>Person本身是一个普通函数，但当通过new来创建对象时，Person就是构造函数了。</p>

<p>JS引擎执行这句代码时，在内部做了很多工作，用伪代码模拟其工作流程如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new Person("John") = {
  var obj = {};
	obj.__proto__ = Person.prototype;
	// 此时便建立了obj对象的原型链：
	// obj-&gt;Person.prototype-&gt;Object.prototype-&gt;null

	var result = Person.call(obj,"John"); // 相当于obj.Person("John")

	// 如果无返回值或者返回一个非对象值，则将obj返回作为新对象：
	return typeof result === 'object' ? result || obj : obj;
}
</code></pre></div></div>

<p>可以看到，这里的obj经返回后会被赋给john变量：</p>

<p>obj.name是在<code class="language-plaintext highlighter-rouge">Person.call(obj,"John")</code>这句话执行之后就有了“John”这个值；</p>

<p>等到obj经返回被赋给john之后，john.name就是“John”了。</p>

<p>画出最终<code class="language-plaintext highlighter-rouge">var john = new Person("John");</code>这一句代码涉及到的对象和它们间的关系：</p>

<p><img src="https://cloud.az22c.top/js-new-process-1.png-az22cgithub" alt="js-new-process-1" /></p>

<blockquote>
  <p>如果看不懂图，可以先看我以往文章的介绍： <a href="https://blog.az22c.top/2017/08/08/js-proto/">理解prototype、proto和constructor等关系</a></p>
</blockquote>

<h2 id="控制台结果解析">控制台结果解析</h2>

<p>分析完了 john 的产生过程，我们再分析一下控制台输出结果：</p>

<p>这个例子的代码全部执行完，最终涉及到的对象和它们间的关系如图：</p>

<p><img src="https://cloud.az22c.top/js-new-process-2.png-az22cgithub" alt="js-new-process-2" /></p>

<ul>
  <li><a href="http://john.name/">john.name</a>： 临时变量obj有name，obj经返回被赋给john，john的一些属性由此而来。</li>
  <li>john.hairColor：john实例对象 先查找自身的 hairColor，<strong>没有找到便会沿着原型链查找</strong>，在上述例子中，我们仅在 Person 对象上定义了 hairColor，并没有在其原型链上定义，因此找不到。</li>
  <li>john.height：john实例对象 先查找自身的 height，<strong>没有找到便会沿着原型链查找</strong>，原型链上也没有，因此找不到。</li>
  <li>john.say：john会先查找自身的 say 方法，没有找到便会沿着原型链查找，在上述例子中，我们在 Person.prototype上定义了say，因此在原型链上找到了say 方法。</li>
</ul>

<p>另外，在 say 方法中还访问<code class="language-plaintext highlighter-rouge">this.name</code>，这里的 this 指的是其调用者。如果john调用say，john就是调用者，因此输出john.name的值。</p>

<hr />

<p>对于Person来说，它本身也是一个对象，因此它在访问属性和方法时也遵守上述查找规则，所以：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Person.name</code> —&gt; Person <strong>// 这是特殊情况</strong></li>
  <li>Person.hairColor —&gt; “black”</li>
  <li>Person.say() —&gt; Person.say is not a function</li>
</ul>

<p>需要注意的是，Person 先查找自身的 name，找到了 name，<strong>但这个 name 并不是我们定义的 name，而是函数对象内置的属性</strong>，一般情况下，函数对象在产生时会内置 name 属性并将函数名作为赋值（仅函数对象）。</p>

<p>另外，Person 在自身没有找到 say() 方法，也会沿着其原型链查找：</p>

<p>Person 的原型链： <strong>Person-&gt;Function.prototype-&gt;Object.prototype-&gt;null</strong> ，这原型链在 <a href="https://blog.az22c.top/2017/08/08/js-proto/">往期文章</a> 里面我有介绍到。</p>

<p>由于 Person 的原型链上也没有定义 say 方法，因此返回异常提示。</p>

<h2 id="总结new的过程中发生了什么">总结new的过程中发生了什么</h2>

<p>[1] 导致john继承了Person.prototype：</p>

<p>令john的<code class="language-plaintext highlighter-rouge">__proto__属性</code>指向Person.prototype，确立了这条原型链， 导致 john 能通过原型链继承Person.prototype 中的部分属性，可以简单地视john和Person.prototype是继承关系。</p>

<p>[2] john是 Person构造函数 的实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上：
john instanceof Person; //true
</code></pre></div></div>

<p>这个过程中Person构造函数被调用并发挥了作用。其结果是，经过new创建实例对象后，实例对象可以拥有自己的属性和方法。</p>
:ET