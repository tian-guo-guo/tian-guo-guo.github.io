I"<h1 id="将伪数组转成真实数组的方法四种"><a href="https://www.cnblogs.com/chenpingzhao/p/4764791.html">将伪数组转成真实数组的方法（四种）</a></h1>

<p><code class="language-plaintext highlighter-rouge">伪数组</code>也叫<code class="language-plaintext highlighter-rouge">类数组</code>，常见的伪数组有<code class="language-plaintext highlighter-rouge">arguments</code>、通过<code class="language-plaintext highlighter-rouge">document.getElements</code>..获取到的内容等，这些伪数组具有<code class="language-plaintext highlighter-rouge">length</code>属性，也是一个一个的元素组成的，但是构造器不是Array，不能使用数组的方法</p>

<p>伪数组如何转换成真正数组，其实我们很少去这么做，但是那帮面试官可能会问，并且不止一种方法让你去实现</p>

<h3 id="方式一">方式一</h3>

<blockquote>
  <p>创建一个新数组，遍历这个伪数组，并将其每一项添加到新数组中。（比较low,面试只回答这个，等着<code class="language-plaintext highlighter-rouge">被毙</code>吧）</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> var ul=document.getElementsByTagName("li");
 var newArr=[];

 for(var i=0;i&lt;ul.length;i++){
     newArr.push(ul[i]);
 }
 console.log(newArr)
复制代码
</code></pre></div></div>

<h3 id="方式二">方式二</h3>

<blockquote>
  <p>使用<code class="language-plaintext highlighter-rouge">[].slice.call(obj)</code>， 数组的<code class="language-plaintext highlighter-rouge">slice()</code>方法,它返回的是数组，使用<code class="language-plaintext highlighter-rouge">call</code>或者<code class="language-plaintext highlighter-rouge">apply</code>指向伪数组</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let obj = {
    0: "a",
    1: "b",
    length: 2
}

let arr = [].slice.call(obj);
console.log(arr);  // ['a','b']
复制代码
</code></pre></div></div>

<p><strong>注意</strong></p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Array.prototype.slice.call(obj)</code>与<code class="language-plaintext highlighter-rouge">[].slice.call(obj)</code>是一样的，但是<code class="language-plaintext highlighter-rouge">Array.prototype.slice.call()</code>的效率相对比较高一点</p>
</blockquote>

<p><strong>模拟slice的实现</strong></p>

<p><img src="https://cdn.jsdelivr.net/gh/tian-guo-guo/cdn@master/assets/picgoimg/20201016221612.png" alt="enter description here" /></p>

<h3 id="方式三">方式三</h3>

<blockquote>
  <p>使用扩展运算符<code class="language-plaintext highlighter-rouge">...</code>，比如使用<code class="language-plaintext highlighter-rouge">[...obj]</code>，需要保证obj是可迭代</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let obj = {
    0: "a",
    1: "b",
    [Symbol.iterator]() {  // 让Obj是可迭代的
        let index = 0;
        return {
            next: () =&gt; {
                return {
                    value: this[index],
                    done: this.length === index++
                }
            }
        }
    },
    length: 2
}


let realArray = [...obj]
console.log(realArray)      //[ 'a', 'b' ]
复制代码
</code></pre></div></div>

<p><strong>注意</strong></p>

<blockquote>
  <p>使用该种方式，必须保证数据源是<code class="language-plaintext highlighter-rouge">可迭代</code>的，否则报错</p>
</blockquote>

<h3 id="方式四">方式四</h3>

<blockquote>
  <p>使用<code class="language-plaintext highlighter-rouge">ES6</code>中数组的新方法 <code class="language-plaintext highlighter-rouge">Array.from</code>，此种方法，对数据源没有特殊的要求，数据源可以不能迭代</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let obj = {
    0: "a",
    1: "b",
    length: 2
}

let arr = Array.from(obj);
console.log(arr);  // ['a','b']
</code></pre></div></div>

<p><a href="https://juejin.im/post/6844903987964018695">Link</a></p>

:ET