I"3<h2 id="javascript">JavaScript</h2>

<h3 id="创建一个对象">创建一个对象</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">age</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">sing</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="谈谈对this对象的理解">谈谈对this对象的理解？</h3>

<p>this 是 js 的一个关键字，随着函数使用场合不同，this 的值会发生变化。</p>

<p>但是总有一个原则，那就是 this 指的是调用函数的那 个对象。</p>

<p>this一般情况下：是全局对象 Global。 作为方法调 用，那么 this 就是指这个对象</p>

<blockquote>
  <p>全局作用域下的this指向window
如果给元素的事件行为绑定函数，那么函数中的this指向当前被绑定的那个元素
函数中的this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this就指向谁，如果没有点，指向window
自执行函数中的this永远指向window
定时器中函数的this指向window
构造函数中的this指向当前的实例
call、apply、bind可以改变函数的this指向
箭头函数中没有this，如果输出this，就会输出箭头函数定义时所在的作用域中的this</p>
</blockquote>

<p>this绑定函数的执行上下文，谁调用它，它就指向谁。分为默认绑定、显式绑定、隐式绑定、apply/call/bind绑定、new绑定和箭头函数绑定</p>

<p>默认绑定:严格模式下this指向undefined，非严格模式this指向window</p>

<p>call、apply、bind都可以改变this的指向，但是apply接收参数数组，call接收的是参数列表 bind接收的是参数列表，但是apply和call调用就执行，bind需要手动执行</p>

<p>箭头函数绑定:箭头函数的this是父作用域的this，不是调用时的this,其他方法的this是动态的，而箭头函数的this是静态的</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">name</span><span class="o">=</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span>
<span class="kd">const</span> <span class="nx">obj</span><span class="o">=</span><span class="p">{</span>
    <span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">age</span><span class="p">:</span><span class="mi">22</span><span class="p">,</span>
    <span class="na">getName</span><span class="p">:()</span><span class="o">=&gt;</span><span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
    <span class="p">},</span>
    <span class="na">getAge</span><span class="p">:</span><span class="kd">function</span><span class="p">(){</span>
        <span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">getName</span><span class="p">();</span><span class="c1">//window a</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">getAge</span><span class="p">();</span><span class="c1">//22</span>
</code></pre></div></div>

<p>优先级:箭头函数&gt;new绑定&gt;显示绑定/apply/bind/call&gt;隐式绑定&gt;默认绑定</p>

<h3 id="new创建对象发生了什么用代码写出来">New创建对象发生了什么，用代码写出来</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">obj</span><span class="o">=</span><span class="p">{};</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">_proto_</span><span class="o">=</span><span class="nx">Base</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">Bash</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li>创建一个空对象，并且this变量引用该对象，同时还继承了这个函数的原型</li>
  <li>属性和方法被加入到this引用的对象里</li>
  <li>新创建的对象由this引用，最后隐式返回this</li>
</ol>

<h3 id="json-的了解">JSON 的了解？</h3>

<p>JSON(JavaScript Object Notation) 是一种轻量 级的数据交换格式。它是基于 JavaScript的一个子 集。数据格式简单, 易于读写, 占用带宽小 {‘age’:’12’, ‘name’:’back’}</p>

<h3 id="js延迟加载的方式有哪些">js延迟加载的方式有哪些？</h3>

<p>defer和 async、动态创建 DOM 方式（用得最多）、 按需异步载入 js</p>

<h3 id="es5的继承和es6的继承有什么区别">ES5的继承和ES6的继承有什么区别？</h3>

<p>ES5的继承时通过prototype或构造函数机制来实现。<strong>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上</strong>（Parent.apply(this)）。</p>

<p>ES6的继承机制完全不同，<strong>实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this</strong>。</p>

<p>具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。</p>

<p>ps：super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错。</p>

<h3 id="es6新特性"><strong>es6新特性</strong></h3>

<p>说的越多越好</p>

<p><strong>1. const 和 let</strong></p>

<p><code class="language-plaintext highlighter-rouge">let</code>: 声明在代码块内有效的变量。</p>

<p>特点：</p>

<ol>
  <li>在存在变理提升（不能在变量声明之前使用）</li>
  <li>let的暂时性死区： 其实与1差不多，只要在块作用域有声明，就不能在本作用域声明前用主个变量。</li>
  <li>不允许重复声明。</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">const</code>: 声明一个只读的常量</p>

<p>特点：</p>

<ol>
  <li>一但声明，这个值不能被改变（对于引用类型，是引用的地址不能被改变）</li>
  <li>声明时必须赋值</li>
</ol>

<blockquote>
  <p>面试中常会问到var let const 三都的区别，回答的时候注重各自的特点，其实const let就是弥补var 的各种缺点，两都的特点就是var 的缺点。
  工作中声明变量多用const 和 let
  其中当声明的变量为引用类型如Array，如果没有直接更改引用的地址，可以使用const</p>
</blockquote>

<p><strong>2. 解构赋值</strong></p>

<p>什么是解构赋值？</p>

<p>按照一定模式从数组或对象中提取值，然后对变量进行赋值（先提取，再赋值）</p>

<p>数组：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="c1">// 以下的结果为右边数剩下的值所组成的数组</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">c</span><span class="p">,</span> <span class="nx">d</span> <span class="p">,...</span><span class="nx">e</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="c1">// 有默认值的写法</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">f</span> <span class="o">=</span> <span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">// f = 100</span>
<span class="c1">// 其中String也被视为类数组</span>
<span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">abcd</span><span class="dl">'</span> <span class="c1">// a = a; b = b</span>
</code></pre></div></div>

<p>对象:</p>

<p>变理名要与对象的属性名一样才可以：</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let { foo } = { foo: 1, bar: 2 } // foo = 1
// 重新命名（后面那个才是新变量）
let { foo: newFoo } = { foo: 1, bar: 2 } // newFoo = 1
</code></pre></div></div>

<p>实际使用：</p>

<ol>
  <li>交换两个变量的值</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">]</span>
</code></pre></div></div>

<p>\2. 函数的封装</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">fn</span><span class="p">({</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其中，函数参数为一个对象，不会像<code class="language-plaintext highlighter-rouge">(x, y)</code>的形式这样固定参数的顺序，而<code class="language-plaintext highlighter-rouge">{} = {}</code>后面又赋一个空的对象就是为了在调用fn时不传参数而不会抛出错误导至程序中止</p>

<p>\3. 函数返回值的解构</p>

<p>函数返回多个值</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 有次序的</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">]</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">()</span>
<span class="c1">// 无次序的</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">}</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">()</span>
</code></pre></div></div>

<p><strong>3. 模板字符串</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">h</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
<span class="s2">`</span><span class="p">${</span> <span class="nx">h</span> <span class="p">}</span><span class="s2"> word`</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">${}</code>中可以使用任意的javaScript表达试、运算、引用对象属性、函数调用等。结果是其返回值。</p>

<p>可以换行，但是所有的空格和换行会被保留。</p>

<p>特点：</p>

<p>可以换行，但是所有的空格和换行会被保留。</p>

<p><code class="language-plaintext highlighter-rouge">${}</code>中可以使用任意的javaScript表达试、运算、引用对象属性、函数调用等。结果是其返回值。</p>

<p><strong>4. 函数的扩展</strong></p>

<ol>
  <li>函数的默认值</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">m</span><span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>

<p>\2. rest参数（用于获取函数的多余参数）</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">a</span><span class="p">(...</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// value 是一个数组，第个元素是传入的各个参数</span>
<span class="p">}</span>
</code></pre></div></div>

<p>\3. 函头函数</p>

<p>特点：</p>

<ol>
  <li>函数体内的this = 定义时所在的对像</li>
  <li>不可以当作构造函数（不能用new)</li>
  <li>不可以用arguments对像，可以用rest</li>
  <li>不可以用yield命令（不能用作Generator函数）</li>
</ol>

<blockquote>
  <p>阮老师的书中这一章讲到了有关尾调用，尾递归的内容，值得一看。</p>
</blockquote>

<p><strong>5. 数组的扩展</strong></p>

<ol>
  <li>扩展运算符。</li>
  <li>用于替代数组的<code class="language-plaintext highlighter-rouge">apply</code>。</li>
</ol>

<p>call apply bind的区别：
用于改变this的指向， 第一个参数为this指向的对像，后面的参数是作为函数的参数。
区加在于：call apply 会即调用，而bind是生成一个等调用的函数。call bind参数是一个个用逗号罗列，而apply 是传入一个数组。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="nx">fn</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)()</span>
<span class="c1">// 指最大值</span>
<span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">62</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
</code></pre></div></div>

<ol>
  <li>合并数组</li>
</ol>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ES5
[1, 2].concat(3)
// ES6
[1, 2, ...[3]]
</code></pre></div></div>

<ol>
  <li>新增的方法</li>
  <li>Array.from()将类数组转为数组</li>
</ol>

<ul>
  <li>可遍历的对象(iterable)(Set, Map)</li>
  <li>类似数组的对</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ '0': 'a', '1': 'b' }
</code></pre></div></div>

<ol>
  <li>实例的方法</li>
</ol>

<ul>
  <li><code class="language-plaintext highlighter-rouge">find()</code><code class="language-plaintext highlighter-rouge">findIndex()</code>找出第一个符合条件的成页/下标（位置）</li>
  <li><code class="language-plaintext highlighter-rouge">entries()</code><code class="language-plaintext highlighter-rouge">keys()</code><code class="language-plaintext highlighter-rouge">values()</code> 用于遍历数组。（配合for…of)</li>
  <li><code class="language-plaintext highlighter-rouge">includes()</code> 是否存在指定无素(返回布尔值)</li>
</ul>

<p><strong>5. 对象的扩展</strong></p>

<ol>
  <li>属性的简写：</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">100</span>
<span class="p">{</span> <span class="nx">a</span> <span class="p">}</span>
<span class="c1">// 等同于</span>
<span class="p">{</span> <span class="nl">a</span><span class="p">:</span> <span class="mi">100</span> <span class="p">}</span>
</code></pre></div></div>

<p>方法名同样可以简写，vue中就常常用这种写法：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
<span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">VueComp</span><span class="dl">'</span><span class="p">,</span>
<span class="nx">data</span><span class="p">()</span> <span class="p">{},</span>
<span class="nx">create</span><span class="p">()</span> <span class="p">{},</span>
<span class="p">}</span>
<span class="c1">// 等同于</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
<span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">VueComp</span><span class="dl">'</span><span class="p">,</span>
<span class="na">data</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{},</span>
<span class="na">create</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{},</span>
<span class="p">}</span>
</code></pre></div></div>

<p>\2. 属性名可心使用表达式：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">[</span><span class="nx">foo</span><span class="p">]:</span> <span class="dl">'</span><span class="s1">fooValue</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div></div>

<p>\3. 新增一些方法：</p>

<ul>
  <li>Object.is()</li>
  <li>Object.assign()</li>
  <li>对像的一些遍历：</li>
</ul>

<p>Object.keys(), Object.values(), Object.entries()</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{}</span>
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">values</span><span class="p">(</span><span class="nx">obj</span><span class="p">))</span> <span class="p">{}</span>
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span><span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">obj</span><span class="p">)){}</span>
</code></pre></div></div>

<ul>
  <li>扩展运算符（常用）(es2017新增，在webpack中要另外的babel转换)</li>
</ul>

<p><strong>6. Symbol</strong></p>

<p>javascript又新增的一种数据类型（第七种，另外6种为：<code class="language-plaintext highlighter-rouge">Undefined</code>、<code class="language-plaintext highlighter-rouge">Null</code>、<code class="language-plaintext highlighter-rouge">Boolean</code>、<code class="language-plaintext highlighter-rouge">String</code>、<code class="language-plaintext highlighter-rouge">Number</code>、<code class="language-plaintext highlighter-rouge">Object</code>)</p>

<p>注：symbol作为对象的属性名时不会被<code class="language-plaintext highlighter-rouge">for...in</code>,<code class="language-plaintext highlighter-rouge">for...of</code>,<code class="language-plaintext highlighter-rouge">Object.keys()</code>识别；可以改用<code class="language-plaintext highlighter-rouge">Reflect.ownkeys</code>方法.</p>

<p><strong>7. Set、Map</strong></p>

<p>Set和map是ES6新增的数据结构。</p>

<ul>
  <li>Set</li>
</ul>

<p>特点： 1. 类似数组，但其成员是唯一的。</p>

<ol>
  <li>是一个构造函数。</li>
</ol>

<p>用法：</p>

<p>数组去重：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[...</span><span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">])]</span>
<span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
</code></pre></div></div>

<ul>
  <li>Map</li>
</ul>

<p>特点：</p>

<ol>
  <li>为了解决javascript的对象只能用了符串作为键的问题。</li>
</ol>

<p>用法： （使用实例的set,get,delete方法增，查，删）</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="dl">'</span><span class="s1">aa</span><span class="dl">'</span><span class="p">}</span>
<span class="nx">m</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">'</span><span class="s1">obj as key</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">m</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// 'obj as key'</span>
<span class="nx">m</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
</code></pre></div></div>

<p>也可以在new 时接受一个数组</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">a</span><span class="p">:</span> <span class="dl">'</span><span class="s1">aa</span><span class="dl">'</span><span class="p">}</span>
<span class="kd">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">([</span>
<span class="p">[</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ym</span><span class="dl">'</span><span class="p">],</span>
<span class="p">[</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span> <span class="na">b</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bbbb</span><span class="dl">'</span> <span class="p">}]</span>
<span class="p">])</span>
</code></pre></div></div>

<blockquote>
  <p>这段时间有一个很火的文章讲如何使用map组构来优化长长的if..else的</p>
</blockquote>

<p><strong>8. Promise</strong></p>

<p>是异步编程的一种解决方案。</p>

<p>特点：</p>

<ol>
  <li>状态不受外界影响（有三种状态：padding, fulfilled,redected)</li>
  <li>一旦状态改变就不会再变。</li>
</ol>

<p>用法：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">resolve</span><span class="p">()</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="p">{})</span>
<span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="p">{})</span>
</code></pre></div></div>

<p>注： then方法有两个参数，第一个是成功的回调，第二个为失败的回调，即：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span><span class="p">{},</span> <span class="nx">err</span> <span class="o">=&gt;</span> <span class="p">{})</span>
</code></pre></div></div>

<p>但是最好用catch方法， 因为catch方法会捕获then里的错误，then里有错误程序不会中止。</p>

<p><strong>Promise.all()</strong></p>

<p>将一组promise再包装成一个promise</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">pa</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">p1</span><span class="p">,</span> <span class="nx">p2</span><span class="p">,</span> <span class="nx">p3</span><span class="p">])</span>
</code></pre></div></div>

<p>特点：</p>

<ol>
  <li>当所有都fulfilledj时，promise.all才fulfilled</li>
  <li>当只有一个rejected时，promise.all就会rejected</li>
</ol>

<p><strong>Iterator和for…of</strong></p>

<p>Iterator的3个作用：</p>

<ol>
  <li>为各种数据提供统一的，简便的访问接口</li>
  <li>使数据结构的成员能按某种次序排列</li>
  <li>主要供for…of用</li>
</ol>

<p>原生有iterator的数据结构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Array`, `Map`, `Set`, `String`, `TypeArray`, `arguments`， `NodeList
</code></pre></div></div>

<p>(object是没有的)</p>

<p><strong>for…of与其他循环的比较</strong></p>

<ol>
  <li>for循环写法比较麻烦</li>
  <li>数组的forEach: 无法用break;return跳出循环。</li>
  <li>For…in</li>
</ol>

<ul>
  <li>数组的键名是数字，而for…in以字符串作为键名（也就是用for…in循环数组，其键名是字符串，笔者被坑过）</li>
  <li>不仅可以遍历键名，还可以遍历手动添加的其他键，包括原型链上的</li>
  <li>某些情况下，会心任意次序遍历</li>
  <li>（ for…in主要为对象而设计的）</li>
</ul>

<p><strong>9. Generator与async await</strong></p>

<p>generator是ES6提供的一种异步编程解决方案。使异步写法更像同步。</p>

<p>Async await是ES2017的标准，是generator的一个语法糖。</p>

<p>用法：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
<span class="k">await</span> <span class="p">...</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="k">await</span> <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当执行a时，其不会阻塞涵数外面的代码（a内的代码会安顺序执行）</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">开始</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">a</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">a后面</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// 开始 -&gt; a后面 -&gt; 111</span>
</code></pre></div></div>

<p><strong>10. Class</strong></p>

<p>产生的原因： 原ES5语法的没有成型的类的概念。而面向对象编程又离不开类的概念。</p>

<p>ES5定义一个类:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Point</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
<span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
<span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Point</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>ES6的class:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Point</span> <span class="p">{</span>
<span class="kd">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
<span class="k">this</span><span class="p">.</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
<span class="k">this</span><span class="p">.</span><span class="nx">y</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其中：</p>

<ol>
  <li>constructor方法是类的默认方法，通过new 命令生成对象时会调用该方法，如果声明类时没有定义constructor，会默认定义一个空的。</li>
  <li>生成实例时必须用new ,不用会报错</li>
  <li>不存在变里提升（选定义类，再new实例）</li>
</ol>

<p><strong>类的静态方法：</strong></p>

<p>所有在类中定义的方法都会被实例继承，如果不想被继承，可以在定义时加上static。表示为静态方法。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
<span class="kd">static</span> <span class="nx">match</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="nx">Foo</span><span class="p">.</span><span class="nx">match</span><span class="p">()</span>
<span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">()</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">match</span><span class="p">()</span> <span class="c1">// 报错</span>
</code></pre></div></div>

<p><strong>类的静态属性</strong></p>

<p>很遗憾，ES6没有给类设静态属性，但是可以用以下方法定义(有提案，写方同静态方法)</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{}</span>
<span class="nx">Foo</span><span class="p">.</span><span class="nx">porp</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1">// 使用</span>
<span class="nx">Foo</span><span class="p">.</span><span class="nx">porp</span> <span class="c1">// 1</span>
</code></pre></div></div>

<p><strong>类的实例属性</strong></p>

<p>类的方法默认被实例继承，那么属性呢？也是继承的，写法如下：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Foo</span> <span class="p">{</span>
<span class="nx">myProp</span> <span class="o">=</span> <span class="mi">111</span><span class="p">;</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>classr的继承 extends</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Point</span> <span class="p">{}</span>
<span class="kd">class</span> <span class="nx">PointSon</span> <span class="kd">extends</span> <span class="nx">Point</span> <span class="p">{</span>
<span class="kd">constructor</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
<span class="k">super</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
<span class="k">this</span><span class="p">.</span><span class="nx">z</span> <span class="o">=</span> <span class="nx">z</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其中：</p>

<ol>
  <li>super等同于父类的constructor。</li>
  <li>子类必须在constructor中调用super， 也就是说用extends去继承一个类，就必须调用这个类（父类）的constructor。是因为子类没有自己的this对象，而是继承父类的this，然后对其进行加工</li>
  <li>如果了类没有写constructor，会默认生成一个，并包含了super(…args)</li>
</ol>

<p><strong>11. Module</strong></p>

<p>一种将程序拆分成一个个小模块的支持，或者说是可以将一个个小模块加入到程序中去。</p>

<p>在ES6的module之前，比较流行的模块加载方案有:CommonJS和AMD，前者用于服务器（node)，后者用于浏览器。</p>

<p>区别：</p>

<ol>
  <li>CommondJS和AMD是运行时加载的。</li>
  <li>module是编译时加载的。</li>
  <li>CommondJS输出的是值的复制，而ES6输出的是值的引用</li>
</ol>

<p><strong>ES6模块默认使用严格模式</strong>：</p>

<ul>
  <li>变里必须声明后再使用</li>
  <li>函数的参数不能有同名属性</li>
  <li>不能使用width</li>
  <li>禁止this指向全局对象</li>
</ul>

<p><strong>使用</strong></p>

<p>命令有： <code class="language-plaintext highlighter-rouge">export</code>、<code class="language-plaintext highlighter-rouge">import</code> 、<code class="language-plaintext highlighter-rouge">export default</code></p>

<p>文件a.js</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">export</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div>

<p>相当于</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">export</span> <span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}</span>
</code></pre></div></div>

<p>在文件b.js中引入</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./a.js</span><span class="dl">'</span>
</code></pre></div></div>

<p>引入是重命名</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">a</span> <span class="k">as</span> <span class="nx">reA</span><span class="p">,</span> <span class="nx">b</span> <span class="k">as</span> <span class="nx">reB</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./a.js</span><span class="dl">'</span> <span class="c1">// reA reB是重命名的变量</span>
</code></pre></div></div>

<p>整体引入：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">all</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./a.js</span><span class="dl">'</span>
<span class="nx">all</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// 1</span>
<span class="nx">all</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// 2</span>
<span class="c1">// all 相当于{ a, b }</span>
</code></pre></div></div>

<p><strong>export default默认输出</strong></p>

<p>export default导出的模块在引入时可以自定义命名</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>依然用import 引入,但是不用{}，且可以自定义变量名</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">name</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./a.js</span><span class="dl">'</span>
<span class="nx">name</span><span class="p">()</span>
</code></pre></div></div>

<p><strong>从一个模块导入，然后再导出</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 写法一：</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./a.js</span><span class="dl">'</span>
<span class="k">export</span> <span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}</span>
<span class="c1">// 写法二：</span>
<span class="k">export</span> <span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./a.js</span><span class="dl">'</span>
<span class="c1">// 改名导出</span>
<span class="k">export</span> <span class="p">{</span> <span class="nx">a</span> <span class="k">as</span> <span class="nx">reA</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./a.js</span><span class="dl">'</span>
<span class="c1">// 整体导出</span>
<span class="k">export</span> <span class="o">*</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./a.js</span><span class="dl">'</span>
</code></pre></div></div>

<p><strong>在浏览器中使用module</strong></p>

<p>将script标签的type设为module即可</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 方法一 --&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"module"</span> <span class="na">src=</span><span class="s">"./a.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="c">&lt;!-- 方法二 --&gt;</span>
<span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"module"</span><span class="nt">&gt;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">a</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./a.js</span><span class="dl">'</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>其中：</p>

<ul>
  <li>type=”module”的script内写的代码是在当前作用域，不是在全局。</li>
  <li>模块内自动采用严格模式</li>
  <li>顶层的this指向undefined</li>
  <li>同一个模块如棵加载多次，只执行一次</li>
</ul>

<h3 id="es6的class的es5的类有什么区别">es6的class的es5的类有什么区别</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span><span class="p">.</span><span class="nx">es6</span> <span class="kd">class</span><span class="err">内部定义的方法都是不可枚举的</span>
<span class="mi">2</span><span class="p">.</span><span class="nx">es6</span> <span class="kd">class</span><span class="err">必须用</span><span class="k">new</span><span class="err">调用</span>
<span class="mi">3</span><span class="p">.</span><span class="nx">es6</span> <span class="kd">class</span><span class="err">不存在变量提升</span>
<span class="mi">4</span><span class="p">.</span><span class="nx">es6</span> <span class="kd">class</span><span class="err">默认使用严格模式</span>
<span class="mi">5</span><span class="p">.</span><span class="nx">es6</span> <span class="kd">class</span><span class="err">子类必须在父类的构造函数中调用</span><span class="k">super</span><span class="p">(),</span><span class="err">才有</span><span class="k">this</span><span class="err">对象；而</span><span class="nx">es5</span><span class="err">是先有子类的</span><span class="k">this</span><span class="err">，再调用</span>
</code></pre></div></div>

<h3 id="和区别是什么"><strong><code class="language-plaintext highlighter-rouge">==和===区别是什么？</code></strong></h3>

<blockquote>
  <p>=赋值</p>

  <p>==返回一个布尔值；相等返回true，不相等返回false； 允许不同数据类型之间的比较； 如果是不同类型的数据进行，会默认进行数据类型之间的转换； 如果是对象数据类型的比较，比较的是空间地址</p>

  <p>=== 只要数据类型不一样，就返回false；</p>
</blockquote>

<h3 id="移动端的兼容问题"><strong>移动端的兼容问题</strong></h3>

<blockquote>
  <p>给移动端添加点击事件会有300S的延迟 如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟 一般在移动端用ontouchstart、ontouchmove、ontouchend
  移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上 尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。 用fastclick，<a href="https://link.zhihu.com/?target=https%3A//github.com/ftlabs/fastclick">github.com/ftlabs/fast…</a> 用preventDefault阻止a标签的click 消除 IE10 里面的那个叉号 input:-ms-clear{display:none;}
  设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。</p>

  <p>圆角BUG 某些Android手机圆角失效 background-clip: padding-box; 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport</p>

  <p>设置用户截止缩放，一般写视口的时候就已经写好了。</p>
</blockquote>

<h3 id="typeof和instance-of-检测数据类型有什么区别"><strong>typeof和instance of 检测数据类型有什么区别？</strong></h3>

<blockquote>
  <p>相同点： 都常用来判断一个变量是否为空，或者是什么类型的。</p>

  <p>不同点： typeof 返回值是一个字符串，用来说明变量的数据类型 instanceof 用于判断一个变量是否属于某个对象的实例.</p>
</blockquote>

<h3 id="如何判断一个变量是对象还是数组prototypetostringcall"><strong>如何判断一个变量是对象还是数组（prototype.toString.call()）。</strong></h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。
</code></pre></div></div>

<blockquote>
  <p>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object null返回object。</p>

  <p>installOf() 用来判断A是否是B的实例，installof检查的是原型。</p>

  <p>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString() 就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p>

  <p>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</p>

  <p>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</p>
</blockquote>

<h3 id="使元素消失的方法"><strong>使元素消失的方法</strong></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">visibility</span><span class="p">:</span><span class="nx">hidden</span><span class="err">、</span><span class="nx">display</span><span class="p">:</span><span class="nx">none</span><span class="err">、</span><span class="nx">z</span><span class="o">-</span><span class="nx">index</span><span class="o">=-</span><span class="mi">1</span><span class="err">、</span><span class="nx">opacity</span><span class="err">：</span><span class="mi">0</span>
<span class="mi">1</span><span class="p">.</span><span class="nx">opacity</span><span class="err">：</span><span class="mi">0</span><span class="p">,</span><span class="err">该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如</span><span class="nx">click</span><span class="err">事件也能触发</span>
<span class="mi">2</span><span class="p">.</span><span class="nx">visibility</span><span class="p">:</span><span class="nx">hidden</span><span class="p">,</span><span class="err">该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件</span>
<span class="mi">3</span><span class="p">.</span><span class="nx">display</span><span class="p">:</span><span class="nx">node</span><span class="p">,</span> <span class="err">把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉</span>
</code></pre></div></div>

<h3 id="实现页面加载进度条">实现页面加载进度条</h3>

<h3 id="常见的设计模式有哪些"><strong>常见的设计模式有哪些？</strong></h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1、js工厂模式
2、js构造函数模式
3、js原型模式
4、构造函数+原型的js混合模式
5、构造函数+原型的动态原型模式
6、观察者模式
7、发布订阅模式
</code></pre></div></div>

<h3 id="事件委托">事件委托</h3>

<h3 id="实现extend函数">实现extend函数</h3>

<h3 id="为什么会有跨域的问题以及解决方式">为什么会有跨域的问题以及解决方式？</h3>

<h3 id="jsonp原理postmessage原理">jsonp原理、postMessage原理？</h3>

<h3 id="实现拖拽功能比如把5个兄弟节点中的最后一个节点拖拽到节点1和节点2之间">实现拖拽功能，比如把5个兄弟节点中的最后一个节点拖拽到节点1和节点2之间</h3>

<h3 id="动画settimeout何时执行requestanimationframe的优点">动画：setTimeout何时执行，requestAnimationFrame的优点</h3>

<h3 id="手写parseint的实现要求简单一些把字符串型的数字转化为真正的数字即可但不能使用js原生的字符串转数字的api比如number">手写parseInt的实现：要求简单一些，把字符串型的数字转化为真正的数字即可，但不能使用JS原生的字符串转数字的API，比如Number()</h3>

<h3 id="写一个通用的事件侦听器函数">写一个通用的事件侦听器函数</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// event(事件)工具集，来源： https://github.com/markyun markyun.Event = {</span>

<span class="c1">// 页面加载完成后 readyEvent : function(fn) { if (fn==null) { fn=document; } var oldonload = window.onload; if (typeof window.onload != 'function') { window.onload = fn; } else { window.onload = function() { oldonload(); fn(); };</span>
<span class="p">}</span>

<span class="p">},</span> <span class="c1">// 视能力分别使用 dom0||dom2||IE方式 来 绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) { if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent('on' + type, function() { handler.call(element); }); } else { element['on' + type] = handler; }</span>

<span class="p">},</span> <span class="c1">// 移除事件 removeEvent : function(element, type,handler) { if (element.removeEnentListener) { element.removeEnentListener(type, handler, false); } else if (element.datachEvent) { element.detachEvent('on' + type, handler); } else { element['on' + type] = null; } }, // 阻止事件 (主要是事件冒泡，因为 IE不支持 事件捕获) stopPropagation : function(ev) { if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; }</span>

<span class="p">},</span> <span class="c1">// 取消事件的默认行为 preventDefault : function(event) {if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; }</span>

<span class="p">},</span> <span class="c1">// 获取事件目标 getTarget : function(event) { return event.target || event.srcElement; }, // 获取 event对象的引用，取到事件的所有信 息，确保随时能使用 event； getEvent : function(e) { var ev = e || window.event; if (!ev) { var c = this.getEvent.caller; while (c) { ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) { break; }c = c.caller;}} return ev;}};</span>
</code></pre></div></div>

<h3 id="异步加载的方式">异步加载的方式</h3>

<p>(1) defer， 只支持 IE</p>

<p>(2) async：</p>

<p>(3) 创建 script， 插入到 DOM中， 加载完毕 后 callBack</p>

<p>documen.write和 innerHTML的区别</p>

<p>document.write只能重绘整个页面</p>

<p>innerHTML可以重绘页面的一部分</p>

<h3 id="async-await函数"><strong>async await函数</strong></h3>

<blockquote>
  <p>async/await函数是异步代码的新方式</p>

  <p>async/await是基于promise实现的</p>

  <p>async/await使异步代码更像同步代码</p>

  <p>await 只能在async函数中使用，不能再普通函数中使用，要成对出现</p>

  <p>默认返回一个promise实例，不能被改变</p>

  <p>await下面的代码是异步，后面的代码是同步的</p>
</blockquote>

<h3 id="js中同步和异步以及js的事件流"><strong>JS中同步和异步,以及js的事件流</strong></h3>

<blockquote>
  <p>同步：在同一时间内做一件事情</p>

  <p>异步：在同一时间内做多个事情 JS是单线程的，每次只能做一件事情，JS运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。</p>
</blockquote>

<h3 id="js中常见的异步任务">JS中常见的异步任务</h3>
<p>定时器、ajax、事件绑定、回调函数、async await、promise</p>

<h3 id="22tcp的三次握手和四次挥手">22.TCP的三次握手和四次挥手</h3>
<p>三次握手</p>

<blockquote>

  <p>第一次握手：客户端发送一个SYN码给服务器，要求建立数据连接；
  第二次握手： 服务器SYN和自己处理一个SYN（标志）；叫SYN+ACK（确认包）；发送给客户端，可以建立连接
第三次握手： 客户端再次发送ACK向服务器，服务器验证ACK没有问题，则建立起连接；
  四次挥手</p>

  <p>第一次挥手： 客户端发送FIN(结束)报文，通知服务器数据已经传输完毕；
  第二次挥手: 服务器接收到之后，通知客户端我收到了SYN,发送ACK(确认)给客户端，数据还没有传输完成
  第三次挥手： 服务器已经传输完毕，再次发送FIN通知客户端，数据已经传输完毕
第四次挥手： 客户端再次发送ACK,进入TIME_WAIT状态；服务器和客户端关闭连接；</p>
</blockquote>

<h3 id="为什么建立连接是三次握手而断开连接是四次挥手呢">为什么建立连接是三次握手，而断开连接是四次挥手呢?</h3>
<p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>

<h3 id="事件流">事件流</h3>

<p>DOM2事件流分为三个部分:事件捕获、处于目标、事件冒泡。</p>

<p><strong>事件冒泡</strong>是指事件从执行的元素开始往上层遍历执行</p>

<p><strong>事件捕获</strong>是指事件从根元素开始从外向里执行</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;!</span><span class="nx">DOCTYPE</span> <span class="nx">html</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">html</span> <span class="nx">lang</span><span class="o">=</span><span class="dl">"</span><span class="s2">en</span><span class="dl">"</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">head</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">meta</span> <span class="nx">charset</span><span class="o">=</span><span class="dl">"</span><span class="s2">UTF-8</span><span class="dl">"</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">title</span><span class="o">&gt;</span><span class="nx">Title</span><span class="o">&lt;</span><span class="sr">/title</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/head</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="nx">body</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="nx">button</span> <span class="nx">id</span><span class="o">=</span><span class="dl">"</span><span class="s2">btn</span><span class="dl">"</span><span class="o">&gt;</span><span class="nx">click</span> <span class="nx">Me</span><span class="o">&lt;</span><span class="sr">/button&gt; </span><span class="err"> 
</span><span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
<span class="kd">let</span> <span class="nx">btn</span><span class="o">=</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">btn</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">btn</span><span class="p">.</span><span class="nx">onclick</span><span class="o">=</span><span class="nx">fucntion</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
<span class="p">}</span>
<span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/body</span><span class="err">&gt;
</span><span class="o">&lt;</span><span class="sr">/html</span><span class="err">&gt;
</span></code></pre></div></div>

<p>点击按钮后，事件冒泡的执行顺序是:button-&gt;body-&gt;html-&gt;document</p>

<p>事件捕获的执行顺序则相反:document-&gt;html-&gt;body-&gt;button</p>

<h3 id="前端事件流"><strong>前端事件流</strong></h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。
  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到&lt;html&gt;再到&lt;body&gt;就停止了。
      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。
      3、冒泡阶段：事件又传播回文档
   阻止冒泡事件event.stopPropagation()
	  function stopBubble(e) {
    		if (e &amp;&amp; e.stopPropagation) { // 如果提供了事件对象event 这说明不是IE浏览器
      		e.stopPropagation()
    		} else {
      		window.event.cancelBubble = true //IE方式阻止冒泡
    	      }
  		   }
   阻止默认行为event.preventDefault()
 function stopDefault(e) {
    if (e &amp;&amp; e.preventDefault) {
      e.preventDefault()
    } else {
      // IE浏览器阻止函数器默认动作的行为
      window.event.returnValue = false
    }
  }
</code></pre></div></div>

<h3 id="事件如何先捕获后冒泡"><strong>事件如何先捕获后冒泡？</strong></h3>

<blockquote>
  <p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果， 对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。</p>

  <p>哪些事件不支持冒泡事件：鼠标事件：mouserleave mouseenter 焦点事件：blur focus UI事件：scroll resize</p>
</blockquote>

<h3 id="target和currenttarget区别"><strong>target和currentTarget区别</strong></h3>

<p>target是事件的真正目标</p>

<p>currentTarget是事件处理程序注册的元素</p>

<p><strong>document.ready和window.onload区别</strong></p>

<p>document.ready是dom树加载后执行，而window.onload是整个页面资源加载完后执行，所以document.ready比window.onload先执行</p>

<h3 id="settimeoutsetinterval区别"><strong>setTimeout、setInterval区别</strong></h3>

<p>两者都是定时器，设定一个150ms后执行的定时器不代表150ms后定时器会执行，它表示代码在150ms内会被加入队列，如果这个时间点队列没有其他逻辑在执行，表面上看代码在精确时间执行了。在队列中有其他逻辑时，代码等待时间会超过150ms</p>

<p><strong>setTimeout</strong> 只执行一次</p>

<p><strong>setInterval</strong> 执行多次，属于重复定时器</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的
待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码
</code></pre></div></div>

<h3 id="从浏览器返回html到渲染出页面再到中间涉及到的优化点前端有哪些页面优化方法">从浏览器返回html到渲染出页面，再到中间涉及到的优化点？<strong>前端有哪些页面优化方法?</strong></h3>

<blockquote>
  <p>减少 HTTP请求数
  从设计实现层面简化页面
  合理设置 HTTP缓存
  资源合并与压缩
  合并 CSS图片，减少请求数的又一个好办法。
  将外部脚本置底（将脚本内容在页面信息内容加载后再加载）
  多图片网页使用图片懒加载。
  在js中尽量减少闭包的使用
  尽量合并css和js文件
  尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片
  减少对DOM的操作
  在JS中避免“嵌套循环”和 “死循环”
  尽可能使用事件委托（事件代理）来处理事件绑定的操作</p>
</blockquote>

<p>（看雅虎 14 条性能优化原则）</p>

<p>（1） 减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托 管，data缓存 ，图片服务器。</p>

<p>（2） 前端模板 JS+数据，减少由于 HTML 标签导 致的带宽浪费，前端用变量保存 AJAX 请求结果，每 次操作本地变量，不用请求，减少请求次数</p>

<p>（3） 用 innerHTML 代替 DOM操作， 减少 DOM 操作次数，优化 javascript 性能。</p>

<p>（4） 当需要设置的样式很多时设置 className 而不是直接操作 style。</p>

<p>（5） 少用全局变量、缓存 DOM 节点查找的结果。 减少 IO 读取操作。</p>

<p>（6） 避免使用 CSS Expression（css 表达式)又 称 Dynamic properties(动态属性)。</p>

<p>（7） 图片预加载，将样式表放在顶部，将脚本放 在底部 加上时间戳。</p>

<p>（8） 避免在页面的主体布局中使用 table，table 要等其中的内容完全下载之后才会显示出来，显示比 div+css 布局慢。</p>

<h3 id="浏览器渲染原理及流程-dom---cssom---render---layout---print"><strong>浏览器渲染原理及流程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print</strong></h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>流程：解析html以及构建dom树 -&gt; 构建render树 -&gt;  布局render树 -&gt; 绘制render树
概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树
      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）
      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置
      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点

重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上
	触发重绘的条件：改变元素外观属性。如：color，background-color等
	重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观
注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局

重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。
	每个页面都需要一次回流，就是页面第一次渲染的时候

重排一定会影响重绘，但是重绘不一定会影响重排
</code></pre></div></div>

<blockquote>
  <p>将html代码按照深度优先遍历来生成DOM树。 css文件下载完后也会进行渲染，生成相应的CSSOM。 当所有的css文件下载完且所有的CSSOM构建结束后，就会和DOM一起生成Render Tree。 接下来，浏览器就会进入Layout环节，将所有的节点位置计算出来。 最后，通过Painting环节将所有的节点内容呈现到屏幕上。</p>
</blockquote>

<h3 id="dom和css如何解析如何渲染出元素">DOM和css如何解析，如何渲染出元素？</h3>

<h3 id="回流和重绘区别"><strong>回流和重绘区别</strong></h3>

<p>回流：当渲染树中元素尺寸、结构或者某些属性发生变化时，浏览器重新渲染部分或全部页面的情况叫回流。下列元素改变引发回流:</p>

<ul>
  <li>getBoundingClientRect()</li>
  <li>scrollTo()</li>
  <li>scrollIntoView()或者scrollIntoViewIfneeded</li>
  <li>clientTop、clientLeft、clientWidth、clientHeight</li>
  <li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
  <li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
  <li>getComputedStyle()</li>
</ul>

<p>重绘：当页面中元素样式变化不会改变它在文档流中的位置时，即不会使元素的几何属性发生变化，浏览器会将新样式赋给它并重新绘制页面(比如color、backgroundColor)</p>

<blockquote>
  <p>频繁回流和重绘会引起性能问题</p>
</blockquote>

<p>避免方法:</p>

<ul>
  <li>减少table布局使用</li>
  <li>减少css表达式的使用(如calc())</li>
  <li>减少DOM操作，用documentFragment代替</li>
  <li>将元素设为display:none;操作结束后把它显示回来，因为display:none不会引发回流重绘</li>
  <li>避免频繁读取会引发回流重绘的元素，如果需要最好是缓存起来</li>
  <li>对复杂动画元素使用绝对定位，使它脱离文档流</li>
  <li>减少使用行内样式</li>
</ul>

<h3 id="防抖节流"><strong>防抖节流</strong></h3>

<p>节流:多次触发事件时，一段时间内保证只调用一次。以动画为例，人眼中一秒播放超过24张图片就会形成动画，假设有100张图片，我们一秒播放100张过于浪费，一秒播放24张就够了。</p>

<p>防抖:持续触发事件后，时间段内没有再触发事件，才调用一次。以坐电梯为例，电梯10s运行一次。如果快要运行时进来一个人，则重新计时。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//节流</span>
<span class="kd">function</span> <span class="nx">throttle</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span><span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">timer</span><span class="o">=</span><span class="kc">null</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">timer</span><span class="p">){</span>
      <span class="nx">timer</span><span class="o">=</span><span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
        <span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">arguments</span><span class="p">)</span>
        <span class="nx">timer</span><span class="o">=</span><span class="kc">null</span>
      <span class="p">},</span><span class="nx">delay</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//防抖</span>
<span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span><span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">timer</span><span class="o">=</span><span class="kc">null</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">timer</span><span class="p">){</span>
      <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timer</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">timer</span><span class="o">=</span><span class="nx">setTimeout</span><span class="p">(()</span><span class="o">=&gt;</span><span class="p">{</span>
      <span class="nx">fn</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">arguments</span><span class="p">)</span>
    <span class="p">},</span><span class="nx">delay</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="什么是防抖和节流有什么区别如何实现">什么是防抖和节流？有什么区别？如何实现？</h3>

<p><strong>防抖</strong></p>

<blockquote>
  <p>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间</p>
</blockquote>

<ul>
  <li>思路：</li>
</ul>

<blockquote>
  <p>每次触发事件时都取消之前的延时调用方法</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">timeout</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// 创建一个标记用来存放定时器的返回值</span>
      <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="nx">clearTimeout</span><span class="p">(</span><span class="nx">timeout</span><span class="p">);</span> <span class="c1">// 每当用户输入的时候把前一个 setTimeout clear 掉</span>
        <span class="nx">timeout</span> <span class="o">=</span> <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数</span>
          <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
        <span class="p">},</span> <span class="mi">500</span><span class="p">);</span>
      <span class="p">};</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">sayHi</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">防抖成功</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">inp</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">inp</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">inp</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">input</span><span class="dl">'</span><span class="p">,</span> <span class="nx">debounce</span><span class="p">(</span><span class="nx">sayHi</span><span class="p">));</span> <span class="c1">// 防抖</span>
</code></pre></div></div>

<p><strong>节流</strong></p>

<blockquote>
  <p>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</p>
</blockquote>

<ul>
  <li>思路：</li>
</ul>

<blockquote>
  <p>每次触发事件时都判断当前是否有等待执行的延时函数</p>
</blockquote>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function throttle(fn) {
      let canRun = true; // 通过闭包保存一个标记
      return function () {
        if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
        canRun = false; // 立即设置为false
        setTimeout(() =&gt; { // 将外部传入的函数的执行放在setTimeout中
          fn.apply(this, arguments);
          // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
          canRun = true;
        }, 500);
      };
    }
    function sayHi(e) {
      console.log(e.target.innerWidth, e.target.innerHeight);
    }
    window.addEventListener('resize', throttle(sayHi));
</code></pre></div></div>

<h3 id="js为什么需要放在body更好的回答其实是浏览器的渲染引擎和js解析引擎的冲突当然回答js是单线程执行也没问题如何优化">js为什么需要放在body(更好的回答其实是浏览器的渲染引擎和js解析引擎的冲突，当然回答js是单线程执行也没问题,如何优化)？</h3>

<h3 id="操作dom为什么是昂贵的">操作DOM为什么是昂贵的？</h3>

<h3 id="js如何执行even-loop宏任务微任务事件队列promiseasyncawait">js如何执行(even Loop/宏任务、微任务，事件队列，promise,async/await)？</h3>

<h3 id="异步回调如何解决回调地狱"><strong>异步回调（如何解决回调地狱）</strong></h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>promise、generator、async/await
promise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理
	  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱
	  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）
	  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败
		promise.all() 里面状态都改变，那就会输出，得到一个数组
		promise.race() 里面只有一个状态变为rejected或者fulfilled即输出
		promis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）
</code></pre></div></div>

<h3 id="浏览器事件循环和node事件循环"><strong>浏览器事件循环和node事件循环</strong></h3>

<p>浏览器事件循环:</p>

<ol>
  <li>同步任务在主线程执行，在主线程外还有个任务队列用于存放异步任务</li>
  <li>主线程的同步任务执行完毕，异步任务入栈，进入主线程执行</li>
  <li>上述的两个步骤循环，形成eventloop事件循环 浏览器的事件循环又跟宏任务和微任务有关，两者都属于异步任务。</li>
</ol>

<blockquote>
  <p>js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入任务队列，再执行微任务，将微任务放入任务队列，他俩进入的不是同一个任务队列。往外读取的时候先从微任务里拿这个回调函数，然后再从宏任务的任务队列上拿宏任务的回调函数</p>
</blockquote>

<p>宏任务:</p>

<ul>
  <li>script</li>
  <li>定时器 setTimeout setInterval setImmediate</li>
</ul>

<p>微任务:</p>

<ul>
  <li>promise</li>
  <li>process.nextTick()</li>
  <li>MutationObserver</li>
</ul>

<p>node事件循环：</p>

<ol>
  <li>timer阶段</li>
  <li>I/O 异常回调阶段</li>
  <li>空闲预备阶段</li>
  <li>poll阶段</li>
  <li>check阶段</li>
  <li>关闭事件的回调阶段</li>
</ol>

<h3 id="js的作用域">js的作用域？</h3>

<p><strong>全局作用域</strong></p>

<blockquote>
  <p>浏览器打开一个页面时，浏览器会给JS代码提供一个全局的运行环境，那么这个环境就是全局作用域 一个页面只有一个全局作用域，全局作用域下有一个window对象 window是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在window下） 如果是全局变量，都会给window新增一个键值对；属性名就是变量名，属性值就是变量所存储的值 如果变量只被var过，那么存储值是undefined 在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量</p>
</blockquote>

<p><strong>私有作用域</strong></p>

<blockquote>
  <p>函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域） 私有作用域在全局作用域中形成，具有包含的关系； 在一个全局作用域中，可以有很多个私有作用域 在私有作用域下定义的变量都是私有变量 形参也是私有变量 函数体中通过function定义的函数也是私有的，在全局作用域不能使用；</p>
</blockquote>

<p><strong>块级作用域</strong></p>

<blockquote>
  <p>es6中新引入的一种作用域 在js中常见到的if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域 var obj = {} //对象的大括号不是块级作用域 块级作用域中的同一变量不能被重复声明（块级下var和function不能重名，否则会报错） 作用域链</p>
</blockquote>

<p><strong>上级作用域</strong></p>

<blockquote>
  <p>函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系 作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链 当前作用域没有的，则会继续向上一级作用域查找 当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）</p>
</blockquote>

<h3 id="你怎样看待闭包closure"><strong>你怎样看待闭包（closure）？</strong></h3>

<p>简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一。</p>

<p>另一个作用，则是保护变量不受外界污染，使其一直存在内存中。</p>

<p>在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">say667</span><span class="p">(){</span>
  <span class="c1">// Local variable that ends up within closure</span>
  <span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">666</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">sayAlert</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">num</span> <span class="o">++</span><span class="p">;</span>
  <span class="k">return</span> <span class="nx">sayAlert</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">sayAlert</span> <span class="o">=</span> <span class="nx">say667</span><span class="p">();</span> 
<span class="nx">sayAlert</span><span class="p">()</span><span class="c1">//执行结果应该弹出的 667</span>
</code></pre></div></div>

<p>执行 say667()后,say667()闭包内部变量会存在, 而 闭包内部函数的内部变量不会存在.使得 Javascript 的垃圾回收机制 GC 不会收回 say667()所占用的 资 源，因为 say667()的内部函数的执行需要依赖 say667()中的变量。这是对闭包作用的非常直白的描 述.</p>

<h3 id="基础类型以及如何判断类型">基础类型以及如何判断类型？</h3>

<h3 id="事件机制以及如何实现一个事件队列">事件机制以及如何实现一个事件队列？</h3>

<h3 id="js深浅拷贝">js深浅拷贝？</h3>

<p>浅克隆: 只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。</p>

<p>深克隆： 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 JSON.parse、JSON.stringify()</p>

<p>浅拷贝:</p>

<ul>
  <li>concat()</li>
  <li>Object.assign()</li>
  <li>slice()</li>
  <li>手写</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">shallowCopy</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">obj</span><span class="o">===</span><span class="dl">'</span><span class="s1">function</span><span class="dl">'</span><span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="o">!==</span><span class="kc">null</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">cloneObj</span><span class="o">=</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">obj</span><span class="p">)?[]:{}</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">prop</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">prop</span><span class="p">)){</span>
        <span class="nx">cloneObj</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span><span class="o">=</span><span class="nx">obj</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cloneObj</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">obj</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>深拷贝:</p>

<ul>
  <li>JSON.stringfy(JSON.parse())</li>
</ul>

<blockquote>
  <p>上面的方法不能解决循环引用，也不能显示函数或undefined</p>
</blockquote>

<ul>
  <li>手写深拷贝</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">deepClone</span><span class="o">=</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="nx">map</span><span class="o">=</span><span class="k">new</span> <span class="nb">WeakMap</span><span class="p">())</span><span class="o">=&gt;</span><span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">obj</span><span class="p">)){</span>
    <span class="k">return</span> <span class="nx">obj</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">newObj</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">obj</span><span class="o">===</span><span class="dl">'</span><span class="s1">object</span><span class="dl">'</span><span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="o">!==</span><span class="kc">null</span><span class="p">){</span>
    <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span><span class="kc">true</span><span class="p">)</span>
    <span class="nx">newObj</span><span class="o">=</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">obj</span><span class="p">)?[]:{};</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">item</span><span class="p">)){</span>
        <span class="nx">newObj</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span><span class="o">=</span><span class="nx">deepClone</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">item</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>
    <span class="k">return</span> <span class="nx">newObj</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="都有哪些方式创建对象静态和动态构造函数创建对象优缺点">都有哪些方式创建对象，静态和动态,构造函数创建对象优缺点</h3>

<p>1：Object构造函数创建</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Person</span> <span class="o">=</span><span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Jason</span><span class="dl">'</span><span class="p">;</span><span class="nx">Person</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
</code></pre></div></div>

<ol>
  <li>使用对象字面量表示法来创建对象</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">Person</span><span class="o">=</span><span class="p">{};</span>   <span class="c1">//等同于var Person =new Object();</span>
<span class="kd">var</span> <span class="nx">Person</span><span class="o">=</span><span class="p">{</span>
<span class="na">name</span><span class="p">:</span><span class="dl">"</span><span class="s2">Jason</span><span class="dl">"</span><span class="p">,</span>
<span class="na">age</span><span class="p">:</span><span class="mi">21</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>使用工厂模式创建对象</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">createPerson</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">job</span><span class="p">)</span>
<span class="p">{</span> <span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span> 
<span class="nx">o</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span> 
<span class="nx">o</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span> 
<span class="nx">o</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span> 
<span class="nx">o</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span>
<span class="p">{</span>  <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>  <span class="p">};</span>
 <span class="k">return</span> <span class="nx">o</span><span class="p">;</span>
 <span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="nx">createPerson</span><span class="p">(</span><span class="dl">'</span><span class="s1">Nike</span><span class="dl">'</span><span class="p">,</span><span class="mi">29</span><span class="p">,</span><span class="dl">'</span><span class="s1">teacher</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="nx">createPerson</span><span class="p">(</span><span class="dl">'</span><span class="s1">Arvin</span><span class="dl">'</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="dl">'</span><span class="s1">student</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li>使用构造函数创建对象</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">job</span><span class="p">)</span>
<span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span> 
<span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span> 
<span class="k">this</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;</span> 
<span class="k">this</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="p">};</span> 
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">Nike</span><span class="dl">'</span><span class="p">,</span><span class="mi">29</span><span class="p">,</span><span class="dl">'</span><span class="s1">teacher</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">person2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">Arvin</span><span class="dl">'</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="dl">'</span><span class="s1">student</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li>原型创建对象模式</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(){}</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Nike</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">jbo</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">teacher</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);};</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">();</span><span class="nx">person1</span><span class="p">.</span><span class="nx">sayName</span><span class="p">();</span>
</code></pre></div></div>

<ol>
  <li>组合使用构造函数模式和原型模式</li>
</ol>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">,</span><span class="nx">job</span><span class="p">)</span>
<span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span><span class="nx">name</span><span class="p">;</span> 
<span class="k">this</span><span class="p">.</span><span class="nx">age</span> <span class="o">=</span> <span class="nx">age</span><span class="p">;</span>
 <span class="k">this</span><span class="p">.</span><span class="nx">job</span> <span class="o">=</span> <span class="nx">job</span><span class="p">;}</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span> 
<span class="na">constructor</span><span class="p">:</span><span class="nx">Person</span><span class="p">,</span>
 <span class="na">sayName</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span>
<span class="p">{</span> <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="p">};</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nx">person1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">Nike</span><span class="dl">'</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="dl">'</span><span class="s1">teacher</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<ol>
  <li></li>
</ol>

<h3 id="js继承方式有哪些"><strong>js继承方式有哪些？</strong></h3>

<blockquote>
  <p>原型链继承 核心： 将父类的实例作为子类的原型</p>

  <p>构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p>

  <p>实例继承 核心：为父类实例添加新特性，作为子类实例返回</p>

  <p>拷贝继承</p>

  <p>组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现 函数复用</p>

  <p>寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实 例方法/属性，避免的组合继承的缺点</p>
</blockquote>

<h3 id="你是如何理解原型和原型链的">你是如何理解原型和原型链的？</h3>

<blockquote>
  <p>把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 __proto__存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过__proto__向当前实例所属类的原型上查找属性或方法的机制，如果找到Object的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回undefined</p>
</blockquote>

<p><strong>原型</strong></p>

<blockquote>
  <p>所有的函数数据类型都天生自带一个prototype属性，该属性的属性值是一个对象 prototype的属性值中天生自带一个constructor属性，其constructor属性值指向当前原型所属的类 所有的对象数据类型，都天生自带一个_proto_属性，该属性的属性值指向当前实例所属类的原型</p>
</blockquote>

<h3 id="原型链说一下继承">原型链、说一下继承</h3>

<p>继承与原型链息息相关。</p>

<p><code class="language-plaintext highlighter-rouge">JavaScript</code> 中没有类的概念的，主要通过原型链来实现继承。通常情况下，继承意味着复制操作，然而 <code class="language-plaintext highlighter-rouge">JavaScript</code> 默认并不会复制对象的属性，相反，<code class="language-plaintext highlighter-rouge">JavaScript</code> 只是在两个对象之间创建一个关联（原型对象指针），这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//原型链继承</span>
<span class="kd">function</span> <span class="nx">Parent</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getValue</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Son</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subProperty</span><span class="o">=</span><span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="o">=</span><span class="k">new</span> <span class="nx">Parent</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">instance</span><span class="o">=</span><span class="k">new</span> <span class="nx">Son</span><span class="p">();</span>
</code></pre></div></div>

<p>原型链继承继承了原型的属性和方法，但是有几个缺点:</p>

<ol>
  <li>原型链中包括引用类型的值时，会被所有实例共享</li>
  <li>不能实现子类向超类的构造函数中添加属性</li>
</ol>

<p>由此产生了借用构造函数继承,解决了原型链继承的缺点，它自身又有缺点:不能实现函数复用</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//借用构造函数继承</span>
<span class="kd">function</span> <span class="nx">Parent</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Son</span><span class="p">(){</span>
    <span class="nx">Parent</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="err">复制代码</span><span class="c1">//组合继承</span>
<span class="kd">function</span> <span class="nx">Parent</span><span class="p">(){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="o">=</span><span class="kc">true</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">colors</span><span class="o">=</span><span class="p">[</span><span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">purple</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">orange</span><span class="dl">'</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getPro</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Son</span><span class="p">(</span><span class="nx">property</span><span class="p">,</span><span class="nx">name</span><span class="p">){</span>
    <span class="nx">Parent</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">property</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="o">=</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="o">=</span><span class="k">new</span> <span class="nx">Parent</span><span class="p">()</span>
</code></pre></div></div>

<p>组合继承避免了原型链和借用构造函数的缺陷,是最常用的继承之一</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//原型继承</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">friends</span> <span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">yuki</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">sakura</span><span class="dl">"</span><span class="p">]</span>
<span class="p">};</span>
<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">"</span><span class="s2">ruby</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">friends</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">"</span><span class="s2">lemon</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">friends</span><span class="p">);</span><span class="c1">//"yuki,sakura,ruby,lemon"</span>
</code></pre></div></div>

<p>原型继承缺点跟原型链继承一样，也是引用类型的属性会被所有实例共享</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//寄生式继承,可以类比设计模式的工厂模式</span>
<span class="kd">function</span> <span class="nx">createAnother</span><span class="p">(</span><span class="nx">obj</span><span class="p">){</span>
  <span class="kd">var</span> <span class="nx">clone</span> <span class="o">=</span> <span class="nx">object</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
  <span class="nx">clone</span><span class="p">.</span><span class="nx">sayHi</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="nx">clone</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>寄生式继承不能做到函数复用</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//寄生组合式继承</span>
<span class="kd">function</span> <span class="nx">Parent</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="o">=</span><span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">colors</span><span class="o">=</span><span class="p">[</span><span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">gray</span><span class="dl">'</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">Parent</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getName</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="o">=</span><span class="nx">name</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">Son</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span><span class="nx">age</span><span class="p">){</span>
    <span class="nx">Parent</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="nx">name</span><span class="p">);</span><span class="c1">//第二次调用Parent()</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="o">=</span><span class="nx">age</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="o">=</span><span class="k">new</span> <span class="nx">Parent</span><span class="p">()</span><span class="c1">//第一次调用Parent()</span>
<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="kd">constructor</span><span class="o">=</span><span class="nx">Son</span><span class="p">;</span>
<span class="nx">Son</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getAge</span><span class="o">=</span><span class="kd">function</span><span class="p">(){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">age</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>寄生组合式继承避免了在子实例上创建多余的属性，又能保持原型链不变，还能正常使用instanceof()和isPrototypeOf()，是最理想的继承方式。</p>

<p>es6方法的继承:通过extends实现</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Parent</span><span class="p">(){</span>
    <span class="kd">constructor</span><span class="p">(){}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nx">Son</span> <span class="kd">extends</span> <span class="nx">Parent</span><span class="p">(){</span>
    <span class="kd">constructor</span><span class="p">(){</span>
        <span class="k">super</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="数组去重">数组去重</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//方法一 使用ES6的Set</span>
<span class="kd">function</span> <span class="nx">filterArr</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//方法二:filter+indexOf()判断，如果数字不是第一次出现则被过滤</span>
<span class="kd">function</span> <span class="nx">filterArr2</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">newArr</span><span class="o">=</span><span class="nx">arr</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span><span class="nx">index</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span><span class="o">===</span><span class="nx">index</span>
  <span class="p">})</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">newArr</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//方法三:双重for循环</span>
<span class="kd">function</span> <span class="nx">filterArr3</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">isRepeat</span><span class="p">,</span><span class="nx">newArr</span><span class="o">=</span><span class="p">[];</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="nx">isRepeat</span><span class="o">=</span><span class="kc">false</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span><span class="o">=</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="o">&lt;</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">===</span><span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]){</span>
        <span class="nx">isRepeat</span><span class="o">=</span><span class="kc">true</span>
        <span class="k">break</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">isRepeat</span><span class="p">){</span>
      <span class="nx">newArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">newArr</span>
<span class="p">}</span>
<span class="c1">//方法四:哈希表</span>
<span class="kd">function</span> <span class="nx">filterArr4</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">seen</span><span class="o">=</span><span class="p">{}</span>
  <span class="k">return</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">seen</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">item</span><span class="p">)?</span><span class="kc">false</span><span class="p">:(</span><span class="nx">seen</span><span class="p">[</span><span class="nx">item</span><span class="p">]</span><span class="o">=</span><span class="kc">true</span><span class="p">)</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="c1">//方法五:sort排序，相同的数字会排在相邻n个位置</span>
<span class="kd">function</span> <span class="nx">filterArr5</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
  <span class="kd">let</span> <span class="nx">lastArr</span><span class="o">=</span><span class="p">[]</span>
  <span class="kd">const</span> <span class="nx">newArr</span><span class="o">=</span><span class="nx">arr</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span><span class="o">-</span><span class="nx">b</span>
  <span class="p">})</span>
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="nx">newArr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">newArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">!==</span><span class="nx">newArr</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]){</span>
      <span class="nx">lastArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">newArr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">lastArr</span>
<span class="p">}</span>
</code></pre></div></div>

<p>ES6的set对象 先将原数组排序，在与相邻的进行比较，如果不同则存入新数组</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function unique(arr){
    var arr2 = arr.sort();
    var res = [arr2[0]];
    for(var i=1;i&lt;arr2.length;i++){
        if(arr2[i] !== res[res.length-1]){
        res.push(arr2[i]);
    }
}
return res;
}
利用下标查询
 function unique(arr){
    var newArr = [arr[0]];
    for(var i=1;i&lt;arr.length;i++){
        if(newArr.indexOf(arr[i]) == -1){
        newArr.push(arr[i]);
    }
}
return newArr;
}
</code></pre></div></div>

<h3 id="call-bind-apply-的区别"><strong>call bind apply 的区别？</strong></h3>

<blockquote>
  <p>call() 和apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。</p>

  <p>call()和apply()的区别就在于，两者之间的参数。</p>

  <p>call()在第一个参数之后的 后续所有参数就是传入该函数的值。</p>

  <p>apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。 bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是 直接执行该函数。他的参数和call()相同。</p>
</blockquote>

<h3 id="箭头函数和普通函数区别"><strong>箭头函数和普通函数区别</strong></h3>

<ul>
  <li>箭头函数没有prototype，所以箭头函数本身没有this</li>
  <li>箭头函数的this指向在定义的时候继承自外层第一个普通函数的this</li>
  <li>箭头函数没有arguments，普通函数有</li>
  <li>使用new调用箭头函数会报错</li>
  <li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
</ul>

<h3 id="promise处理异步"><strong>Promise处理异步</strong></h3>

<blockquote>
  <p>他是ES6中新增加的一个类（new Promise）,目的是为了管理JS中的异步编程的，所以把他称为“Promise设计模式” new Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)== Promise本身是同步编程的，他可以管理异步操作的（重点），new Promise的时候，会把传递的函数立即执行 Promise函数天生有两个参数，resolve(当异步操作执行成功，执行resolve方法),rejected(当异步操作失败，执行reject方法) then()方法中有两个函数，第一个传递的函数是resolve,第二个传递的函数是reject ajax中false代表同步，true代表异步，如果使用异步，不等ajax彻底完成</p>
</blockquote>

<h3 id="手写promise">手写promise</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">myPromise</span><span class="p">(</span><span class="nx">executor</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nb">self</span><span class="o">=</span><span class="k">this</span><span class="p">;</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">status</span><span class="o">=</span><span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">;</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="o">=</span><span class="kc">undefined</span><span class="p">;</span>
    <span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="o">=</span><span class="kc">undefined</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">resolve</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span><span class="o">===</span><span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span>
            <span class="nb">self</span><span class="p">.</span><span class="nx">value</span><span class="o">=</span><span class="nx">value</span>
            <span class="nb">self</span><span class="p">.</span><span class="nx">status</span><span class="o">=</span><span class="dl">"</span><span class="s2">resolved</span><span class="dl">"</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">reject</span><span class="p">(</span><span class="nx">reason</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="nx">status</span><span class="o">===</span><span class="dl">'</span><span class="s1">pending</span><span class="dl">'</span><span class="p">){</span>
            <span class="nb">self</span><span class="p">.</span><span class="nx">reason</span><span class="o">=</span><span class="nx">reason</span>
            <span class="nb">self</span><span class="p">.</span><span class="nx">status</span><span class="o">=</span><span class="nx">status</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">try</span><span class="p">{</span>
        <span class="nx">executor</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="nx">reject</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>手写bind</strong></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">myBind</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">,...</span><span class="nx">args</span><span class="p">){</span>
   <span class="kd">const</span> <span class="nx">fn</span><span class="o">=</span><span class="k">this</span>
    <span class="nx">args</span><span class="o">=</span><span class="nx">args</span><span class="p">?</span><span class="nx">args</span><span class="p">:[]</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nx">newFn</span><span class="p">(...</span><span class="nx">newFnArgs</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">newFn</span><span class="p">){</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nx">fn</span><span class="p">(...</span><span class="nx">args</span><span class="p">,...</span><span class="nx">newFnArgs</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span>  <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,[...</span><span class="nx">args</span><span class="p">,...</span><span class="nx">newFnArgs</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="手写callapply"><strong>手写call、apply</strong></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">myCall</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">,...</span><span class="nx">args</span><span class="p">){</span>
    <span class="nx">context</span><span class="o">=</span><span class="nx">context</span><span class="o">||</span><span class="nb">window</span>
    <span class="nx">args</span><span class="o">=</span><span class="nx">args</span><span class="p">?</span><span class="nx">args</span><span class="p">:[]</span>
    <span class="kd">const</span> <span class="nx">key</span><span class="o">=</span><span class="nb">Symbol</span><span class="p">()</span>
    <span class="nx">context</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="o">=</span><span class="k">this</span>
    <span class="kd">const</span> <span class="nx">result</span><span class="o">=</span><span class="nx">context</span><span class="p">[</span><span class="nx">key</span><span class="p">](...</span><span class="nx">args</span><span class="p">)</span><span class="c1">//通过隐式绑定的方式调用函数</span>
    <span class="k">delete</span> <span class="nx">context</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="c1">//删除添加的属性</span>
    <span class="k">return</span> <span class="nx">result</span><span class="c1">//返回函数调用的返回值</span>
<span class="p">}</span>

<span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">myApply</span><span class="o">=</span><span class="kd">function</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span><span class="nx">args</span><span class="p">){</span>
    <span class="nx">context</span><span class="o">=</span><span class="nx">context</span><span class="o">||</span><span class="nb">window</span>
    <span class="nx">args</span><span class="o">=</span><span class="nx">args</span><span class="o">||</span><span class="p">[]</span>
    <span class="kd">const</span> <span class="nx">key</span><span class="o">=</span><span class="nb">Symbol</span><span class="p">()</span>
    <span class="nx">context</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="o">=</span><span class="k">this</span>
    <span class="kd">const</span> <span class="nx">result</span><span class="o">=</span><span class="nx">context</span><span class="p">[</span><span class="nx">key</span><span class="p">](...</span><span class="nx">args</span><span class="p">)</span>
    <span class="k">delete</span> <span class="nx">context</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="对异步的理解">对异步的理解</h3>

<p>js是单线程的，但不能一直等着一张张图片加载完成吧，写一个回调的函数，谁先完成任务就执行谁。</p>

<h3 id="node的理解以及应用方面优缺点">node的理解以及应用方面，优缺点？</h3>

<p>js开发环境  <strong>在线聊天</strong>    <strong>对象数据库顶层的 API</strong>   <strong>队列输入</strong>   <strong>数据流</strong>    <strong>代理</strong>    <strong>股票交易商的数据界面</strong>   <strong>应用监控仪表板</strong>     <strong>系统监控仪表板</strong>    <strong>服务器端 Web 应用</strong></p>

<p>*（优点）因为 Node 是基于事件驱动和无阻塞的，所以非常适合处理并发请求，</p>

<p>因此构建在 Node 上的代理服务器相比其他技术实现（如 Ruby）的服务器表现要好得多。</p>

<p>此外，与 Node 代理服务器交互的客户端代码是由 javascript 语言编写的，</p>

<p>因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p>

<p>*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，</p>

<p>而且缺少足够多的第三方库支持。看起来，就像是 Ruby/Rails 当年的样子。</p>

<h3 id="伪数组">伪数组</h3>

<p>定义：</p>

<p>1、拥有length属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)
2、不具有数组所具有的方法</p>

<h3 id="伪数组怎么转化为数组">伪数组怎么转化为数组？</h3>

<ol>
  <li>创建一个新数组，遍历这个伪数组，并将其每一项添加到新数组中。</li>
  <li>使用<code class="language-plaintext highlighter-rouge">[].slice.call(obj)</code>， 数组的<code class="language-plaintext highlighter-rouge">slice()</code>方法,它返回的是数组，使用<code class="language-plaintext highlighter-rouge">call</code>或者<code class="language-plaintext highlighter-rouge">apply</code>指向伪数组</li>
  <li>使用扩展运算符<code class="language-plaintext highlighter-rouge">...</code>，比如使用<code class="language-plaintext highlighter-rouge">[...obj]</code>，需要保证obj是可迭代</li>
  <li>使用<code class="language-plaintext highlighter-rouge">ES6</code>中数组的新方法 <code class="language-plaintext highlighter-rouge">Array.from</code>，此种方法，对数据源没有特殊的要求，数据源可以不能迭代</li>
</ol>

<h3 id="怎么判断一个元素是不是数组">怎么判断一个元素是不是数组？</h3>

<ol>
  <li>
    <p>instanceof  a instanceof Array; //true</p>
  </li>
  <li>
    <p>constructor</p>

    <p>let a = [1,3,4];
a.constructor === Array;//true</p>
  </li>
  <li>
    <p>Object.prototype.toString.call()</p>

    <p>let a = [1,2,3]
Object.prototype.toString.call(a) === ‘[object Array]’;//true</p>
  </li>
  <li>
    <p>Array.isArray()</p>

    <p>let a = [1,2,3]
Array.isArray(a);//true</p>
  </li>
</ol>

<h3 id="除了你说的arrayisarray和arrayfrom还有哪些数组的方法">除了你说的Array.isArray和Array.from还有哪些数组的方法？</h3>

<p>var a = Array(3);创建一个数组</p>

<p>ES6 Array.of() 返回由所有参数值组成的数组</p>

<p>ES6 Arrary.from() 将两类对象转为真正的数组</p>

<p>改变原数组的方法(9个):</p>

<p>splice() 添加/删除数组元素</p>

<p>sort() 数组排序</p>

<p>pop() 删除一个数组中的最后的一个元素</p>

<p>shift() 删除数组的第一个元素</p>

<p>push() 向数组的末尾添加元素</p>

<p>unshift()</p>

<p>reverse() 颠倒数组中元素的顺序</p>

<p>ES6: copyWithin() 指定位置的成员复制到其他位置</p>

<p>ES6: fill() 填充数组</p>

<p>不改变原数组的方法(8个):</p>

<p>slice() 浅拷贝数组的元素</p>

<p>join() 数组转字符串</p>

<p>toLocaleString() 数组转字符串</p>

<p>toString() 数组转字符串 不推荐</p>

<p>cancat</p>

<p>ES6扩展运算符<code class="language-plaintext highlighter-rouge">...</code>合并数组</p>

<p>indexOf() 查找数组是否存在某个元素，返回下标</p>

<p>lastIndexOf() 查找指定元素在数组中的最后一个位置</p>

<p>ES7 includes() 查找数组是否包含某个元素 返回布尔</p>

<p>遍历方法(12个):</p>

<p>ES5：    forEach、every 、some、 filter、map、reduce、reduceRight、</p>

<p>ES6：    find、findIndex、keys、values、entries</p>

<h3 id="splice和slicemap和foreach-filterreduce的区别"><strong>splice和slice、map和forEach、 filter()、reduce()的区别</strong></h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组，
 包含从start到end（不包含该元素）的数组方法
	注意：该方法不会更新原数组，而是返回一个子数组
 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）
	splice(index, howmany,item1,...itemx)
		·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置
		·howmany参数：必须，要删除的数量，
		·item1..itemx:可选，向数组添加新项目
3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据
4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素
5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值
6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理	
</code></pre></div></div>

<h3 id="map和foreach的区别">map和forEach的区别</h3>

<p><strong>相同点</strong></p>

<blockquote>
  <p>都是循环遍历数组中的每一项 forEach和map方法里每次执行匿名函数都支持3个参数，参数分别是item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个 匿名函数中的this都是指向window 只能遍历数组</p>
</blockquote>

<p><strong>不同点</strong></p>

<blockquote>
  <p>map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。) map()方法不会改变原始数组 map()方法不会对空数组进行检测 forEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有return，返回值是undefined）
  <strong>注意</strong>：forEach对于空数组是不会调用回调函数的。</p>
</blockquote>

<h3 id="ajax同步和异步的区别">Ajax同步和异步的区别?</h3>

<ol>
  <li>
    <p>通过异步模式，提升了用户体验</p>
  </li>
  <li>
    <p>优化了浏览器和服务器之间的传输，减少不必要 的数据往返，减少了带宽占用</p>
  </li>
  <li>
    <p>Ajax 在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</p>
  </li>
</ol>

<h3 id="ajax的最大的特点是什么">Ajax的最大的特点是什么？</h3>

<p>Ajax 可以实现动态不刷新（局部刷新） readyState 属性 状态 有 5 个可取值：0=未初始化 ，1=正在加载 2=以加载，3=交互中，4=完成</p>

<h3 id="jax-的缺点">jax 的缺点？</h3>

<p>1、ajax 不支持浏览器 back 按钮。</p>

<p>2、安全问题 AJAX 暴露了与服务器交互的细节。</p>

<p>3、对搜索引擎的支持比较弱。</p>

<p>4、破坏了程序的异常机制。</p>

<p>5、不容易调试。</p>

<h3 id="ajax的四个步骤"><strong>Ajax的四个步骤</strong></h3>

<blockquote>
  <p>1.创建ajax实例</p>

  <p>2.执行open 确定要访问的链接 以及同步异步</p>

  <p>3.监听请求状态</p>

  <p>4.发送请求</p>
</blockquote>

<h3 id="ajax中get和post请求的区别"><strong>ajax中get和post请求的区别</strong></h3>

<blockquote>
  <p>get 一般用于获取数据
  get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；
  get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；
  get安全性较低
  get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳
  post 一般用于发送数据
  post传递参数，需要把参数放进请求体中，发送给服务器；
  post请求参数放进了请求体中，对大小没有要求；
  post安全性比较高；
  post请求不会走缓存；</p>
</blockquote>

<h3 id="getpost的区别"><strong>get/post的区别</strong></h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&amp;相连； post方法是把提交的数据放在http包的Body中
2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制
3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值
4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上
</code></pre></div></div>

<h3 id="get请求传参长度的误区get和post请求在缓存方面的区别">get请求传参长度的误区、get和post请求在缓存方面的区别</h3>

<p><strong>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。</strong></p>

<p>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p>

<ul>
  <li>HTTP 协议 未规定 GET 和POST的长度限制</li>
  <li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li>
  <li>不同的浏览器和WEB服务器，限制的最大长度不一样</li>
  <li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li>
</ul>

<p>补充补充一个get和post在缓存方面的区别：</p>

<ul>
  <li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li>
  <li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li>
</ul>

:ET