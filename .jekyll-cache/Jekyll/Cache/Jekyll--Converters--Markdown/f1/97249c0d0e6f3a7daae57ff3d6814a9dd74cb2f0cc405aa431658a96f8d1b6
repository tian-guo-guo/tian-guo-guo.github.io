I"<h1 id="剑指-offer-57-和为s的两个数字"><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">剑指 Offer 57. 和为s的两个数字</a></h1>

<p>tag: easy，数组，滑动窗口</p>

<p><strong>题目：</strong></p>

<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>

<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>

<p><strong>示例1：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：target = 9
输出：[[2,3,4],[4,5]]
</code></pre></div></div>

<p><strong>示例2：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
</code></pre></div></div>

<h1 id="方法一">方法一：</h1>

<p><strong>什么是滑动窗口</strong></p>

<p>滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。</p>

<p>对于这道题来说，数组就是正整数序列[1,2,3,…,n]。我们设滑动窗口的左边界为 i，右边界为 j，则滑动窗口框起来的是一个左闭右开区间 [i, j)。注意，为了编程的方便，滑动窗口一般表示成一个左闭右开区间。在一开始，i=1, j=1，滑动窗口位于序列的最左侧，窗口大小为零。</p>

<p>滑动窗口的重要性质是：窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。如果左右边界向左移动的话，这叫做“回溯”，算法的时间复杂度就可能不止 O(n)。</p>

<p>在这道题中，我们关注的是滑动窗口中所有数的和。当滑动窗口的右边界向右移动时，也就是 j = j + 1，窗口中多了一个数字 j，窗口的和也就要加上 j。当滑动窗口的左边界向右移动时，也就是 i = i + 1，窗口中少了一个数字 i，窗口的和也就要减去 i。滑动窗口只有 右边界向右移动（扩大窗口） 和 左边界向右移动（缩小窗口） 两个操作，所以实际上非常简单。</p>

<p><strong>如何用滑动窗口解这道题</strong></p>

<p>要用滑动窗口解这道题，我们要回答两个问题：</p>

<ul>
  <li>第一个问题，窗口何时扩大，何时缩小？</li>
  <li>第二个问题，滑动窗口能找到全部的解吗？</li>
</ul>

<p>对于第一个问题，回答非常简单：</p>

<ul>
  <li>当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动</li>
  <li>当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动</li>
  <li>当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为 [i,j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动</li>
</ul>

<p>我们一开始要找的是 1 开头的序列，只要窗口的和小于 target，窗口的右边界会一直向右移动。假设 1+2+⋯+8 小于 target，再加上一个 9 之后， 发现 1+2+⋯+8+9 又大于 target 了。这说明 1 开头的序列找不到解。此时滑动窗口的最右元素是 9。</p>

<p>接下来，我们需要找 2 开头的序列，我们发现，2+⋯+8&lt;1+2+⋯+8&lt;target。这说明 2 开头的序列至少要加到 9。那么，我们只需要把原先 1~9 的滑动窗口的左边界向右移动，变成 2~9 的滑动窗口，然后继续寻找。而右边界完全不需要向左移动。</p>

<p>以此类推，滑动窗口的左右边界都不需要向左移动，所以这道题用滑动窗口一定可以得到所有的解。时间复杂度是 O(n)O(n)。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">findContinuousSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 滑动窗口的左边界
</span>        <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 滑动窗口的右边界
</span>        <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 滑动窗口中数字的和
</span>        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">sum</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="c1"># 右边界向右移动
</span>                <span class="nb">sum</span> <span class="o">+=</span> <span class="n">j</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">sum</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">:</span>
                <span class="c1"># 左边界向右移动
</span>                <span class="nb">sum</span> <span class="o">-=</span> <span class="n">i</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># 记录结果
</span>                <span class="n">arr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="c1"># 左边界向右移动
</span>                <span class="nb">sum</span> <span class="o">-=</span> <span class="n">i</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div>

<blockquote>
  <p>执行用时：120 ms, 在所有 Python3 提交中击败了80.07%的用户</p>

  <p>内存消耗：13.5 MB, 在所有 Python3 提交中击败了15.55%的用户</p>
</blockquote>

<p><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/">Link</a></p>

:ET