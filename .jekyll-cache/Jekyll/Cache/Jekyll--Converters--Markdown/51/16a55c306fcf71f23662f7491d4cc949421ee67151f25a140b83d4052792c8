I"$<h1 id="http-强缓存和协商缓存"><a href="https://segmentfault.com/a/1190000011381906">HTTP 强缓存和协商缓存</a></h1>

<p><img src="https://user-gold-cdn.xitu.io/2020/4/15/1717c60dc551869a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>

<h1 id="前言">前言</h1>

<p><strong>强缓存</strong>: 浏览器不会向服务器发送任何请求，直接从本地缓存中读取文件并返回 <code class="language-plaintext highlighter-rouge">Status Code： 200 OK</code>。常见如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Status Code: 200 OK (from memory cache) // 内存缓存
Status Code: 200 OK (from disk cache)   // 磁盘缓存
复制代码
</code></pre></div></div>

<p>读取本地的缓存有<code class="language-plaintext highlighter-rouge">from memory cache</code>和<code class="language-plaintext highlighter-rouge">from disk cache</code>的区别： 这是浏览器的缓存策略。一般<code class="language-plaintext highlighter-rouge">memory cache</code>一般存放比较小的文件，<code class="language-plaintext highlighter-rouge">disk cache</code>一般存放比较大的文件。</p>

<p><strong>协商缓存</strong>: 向服务器发送请求，服务器会根据这个请求的<code class="language-plaintext highlighter-rouge">request header</code>的一些参数来判断是否命中协商缓存。如果命中，则返回<code class="language-plaintext highlighter-rouge">304</code>状态码，并带上新的<code class="language-plaintext highlighter-rouge">response header</code>通知浏览器从缓存中读取资源。</p>

<p>在<code class="language-plaintext highlighter-rouge">Response Headers</code>中展示如下图： <img src="https://user-gold-cdn.xitu.io/2020/4/15/1717c55cd0b2e84d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>

<h2 id="工作流程">工作流程</h2>

<ol>
  <li>浏览器在加载资源时，根据请求头的<code class="language-plaintext highlighter-rouge">expires</code>和<code class="language-plaintext highlighter-rouge">cache-control</code>判断是否命中强缓存，若命中则直接从缓存读取资源，<strong>不会发请求到服务器</strong>，<code class="language-plaintext highlighter-rouge">Status Code</code>显示为<code class="language-plaintext highlighter-rouge">200 OK (from memory cache)</code>或<code class="language-plaintext highlighter-rouge">200 OK (from disk cache)</code></li>
  <li>如果没有命中强缓存，则浏览器会发送一个请求到服务器，通过<code class="language-plaintext highlighter-rouge">Etag</code>和<code class="language-plaintext highlighter-rouge">last-modified</code>验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，状态码为<code class="language-plaintext highlighter-rouge">304 Not Modified</code>，但是不会返回这个资源的数据，浏览器则依然是从缓存中读取资源</li>
  <li>如果前面两个都没有命中，则直接从服务器加载资源，并返回状态码<code class="language-plaintext highlighter-rouge">200</code></li>
</ol>

<h2 id="详细说明">详细说明</h2>

<h3 id="1-expires和cache-control">1. <code class="language-plaintext highlighter-rouge">expires</code>和<code class="language-plaintext highlighter-rouge">cache-control</code></h3>

<p><strong>首先<code class="language-plaintext highlighter-rouge">cache-control</code>的优先级高于<code class="language-plaintext highlighter-rouge">expires</code></strong>。<code class="language-plaintext highlighter-rouge">cache-control</code>在<code class="language-plaintext highlighter-rouge">HTTP/ 1.1</code>中出现，表示的是相对时间。而<code class="language-plaintext highlighter-rouge">Expires</code>在<code class="language-plaintext highlighter-rouge">HTTP/ 1.0</code>中出现，标识一个资源过期时间，是一个绝对时间，由服务器返回，但由于<code class="language-plaintext highlighter-rouge">Expires</code> 受限于本地时间，如果修改了本地时间，则可能会造成缓存失效，因此<code class="language-plaintext highlighter-rouge">Expires</code>有这样的<code class="language-plaintext highlighter-rouge">bug</code>存在。</p>

<h4 id="http-header中常见返回值"><code class="language-plaintext highlighter-rouge">HTTP HEADER</code>中常见返回值:</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Expires: Wed, 15 Apr 2020 01:09:53 GMT

Cache-Control: max-age=86400
复制代码
Cache-Control: no-cache // 可以存储在本地缓存区中，只是在于原始服务器进行新鲜度验证之前，缓存不能将其提供给客户端使用
Cache-Control: no-store // 真正的不缓存数据到本地
Cache-Control: public // 以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器
Cache-Control: private // 只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存
复制代码
</code></pre></div></div>

<h3 id="2-etagif-none-match">2. <code class="language-plaintext highlighter-rouge">ETag</code>、<code class="language-plaintext highlighter-rouge">If-None-Match</code></h3>

<p><code class="language-plaintext highlighter-rouge">ETag</code>和<code class="language-plaintext highlighter-rouge">If-None-Match</code>是组合来使用的。<code class="language-plaintext highlighter-rouge">Etag</code>就像一个指纹，资源变化都会导致<code class="language-plaintext highlighter-rouge">ETag</code>变化，跟最后修改时间没有关系，因此，<code class="language-plaintext highlighter-rouge">ETag</code>可以保证每一个资源是唯一的。<code class="language-plaintext highlighter-rouge">If-None-Match</code>的<code class="language-plaintext highlighter-rouge">header</code>会将上次返回的<code class="language-plaintext highlighter-rouge">Etag</code>发送给服务器，询问该资源的<code class="language-plaintext highlighter-rouge">Etag</code>是否有更新，有变动就会发送新的资源回来。</p>

<p><strong><code class="language-plaintext highlighter-rouge">ETag</code>的优先级比<code class="language-plaintext highlighter-rouge">Last-Modified</code>更高</strong></p>

<p>参考文档： <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/ETag">ETag</a></p>

<p>浏览器在请求时在<code class="language-plaintext highlighter-rouge">Request Headers</code>中携带内容如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If-None-Match: W/"5exxxd45-9xx"
复制代码
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">If-None-Match</code>的值为上次返回的<code class="language-plaintext highlighter-rouge">Etag</code></strong> <img src="https://user-gold-cdn.xitu.io/2020/4/15/1717c51f4c719ccd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /> 如果资源未改变，返回状态码如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Status Code: 304 Not Modified
复制代码
</code></pre></div></div>

<h3 id="3-last-modifiedif-modified-since">3. <code class="language-plaintext highlighter-rouge">Last-Modified</code>、<code class="language-plaintext highlighter-rouge">If-Modified-Since</code></h3>

<p><code class="language-plaintext highlighter-rouge">Last-Modified </code>表示本地文件最后修改日期，浏览器会在<code class="language-plaintext highlighter-rouge">request header</code>加上<code class="language-plaintext highlighter-rouge">If-Modified-Since</code>（上次返回的<code class="language-plaintext highlighter-rouge">Last-Modified</code>的值），如下图所示，询问服务器在该日期后资源是否有更新，如果有更新的话就会将新的资源发送回来。<strong>但是如果在本地打开缓存文件，就会造成<code class="language-plaintext highlighter-rouge">Last-Modified</code>被修改，所以在<code class="language-plaintext highlighter-rouge">HTTP/1.1</code>出现了<code class="language-plaintext highlighter-rouge">ETag</code></strong></p>

<p><img src="https://user-gold-cdn.xitu.io/2020/4/15/1717c54ff200052e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If-Modified-Since: Fri, 10 Apr 2020 14:05:57 GMT
复制代码
</code></pre></div></div>

<h2 id="缓存的选择">缓存的选择</h2>

<p><strong>协商缓存需要配合强缓存使用，如果不启用强缓存的话，协商缓存根本没有意义</strong>。 大部分<code class="language-plaintext highlighter-rouge">web</code>服务器都默认开启协商缓存，而且是同时启用<code class="language-plaintext highlighter-rouge">【Last-Modified，If-Modified-Since】</code>和<code class="language-plaintext highlighter-rouge">【ETag、If-None-Match】</code>。<code class="language-plaintext highlighter-rouge">Etag</code>等一般是在<code class="language-plaintext highlighter-rouge">nginx</code>中配置完成的。</p>

<p>希望对你能有所帮助！</p>

<p><a href="https://juejin.im/post/6844904127760171015">Link</a></p>

:ET