I"<h1 id="剑指-offer-54-二叉搜索树的第k大节点"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">剑指 Offer 54. 二叉搜索树的第k大节点</a></h1>

<p>tag: easy，二叉树，二叉搜索树，递归</p>

<p><strong>题目：</strong></p>

<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>

<p><strong>示例1：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
</code></pre></div></div>

<p><strong>示例2：</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
</code></pre></div></div>

<h1 id="方法一">方法一：</h1>

<p><strong>解题思路：</strong></p>

<blockquote>
  <p>本文解法基于此性质：二叉搜索树的中序遍历为 递增序列 。</p>
</blockquote>

<ul>
  <li>根据以上性质，易得二叉搜索树的 中序遍历倒序 为 递减序列 。</li>
  <li>因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的中序遍历倒序的第 k 个节点”。</li>
</ul>

<blockquote>
  <p><strong>中序遍历</strong> 为 “左、根、右” 顺序，递归法代码如下：</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 打印中序遍历
</span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>  <span class="c1"># 左
</span>    <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="c1"># 根
</span>    <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1"># 右
</span></code></pre></div></div>

<blockquote>
  <p><strong>中序遍历的倒序</strong> 为 “右、根、左” 顺序，递归法代码如下：</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 打印中序遍历倒序
</span><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span>
    <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1"># 右
</span>    <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span> <span class="c1"># 根
</span>    <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>  <span class="c1"># 左
</span></code></pre></div></div>

<ul>
  <li>为求第 k 个节点，需要实现以下 三项工作 ：
    <ol>
      <li>递归遍历时计数，统计当前节点的序号；</li>
      <li>递归到第 k 个节点时，应记录结果 res ；</li>
      <li>记录结果后，后续的遍历即失去意义，应提前终止（即返回）。</li>
    </ol>
  </li>
</ul>

<p><strong>递归解析：</strong></p>

<ol>
  <li>终止条件： 当节点 rootroot 为空（越过叶节点），则直接返回；</li>
  <li>递归右子树： 即 dfs(root.right)；</li>
  <li>三项工作：
    <ol>
      <li>提前返回： 若 k = 0k=0 ，代表已找到目标节点，无需继续遍历，因此直接返回；</li>
      <li>统计序号： 执行 k=k−1 （即从 k 减至 0 ）；</li>
      <li>记录结果： 若 k=0 ，代表当前节点为第 k 大的节点，因此记录 res=root.val ；</li>
    </ol>
  </li>
  <li>递归左子树： 即 dfs(root.left) ；</li>
</ol>

<ul>
  <li>复杂度分析：
    <ul>
      <li>时间复杂度 O(N) ： 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 O(N) 时间。</li>
      <li>空间复杂度 O(N)O(N) ： 当树退化为链表时（全部为右子节点），系统使用 O(N)O(N) 大小的栈空间。</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
        
<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">kthLargest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">res</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>

        <span class="bp">self</span><span class="p">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">res</span>
</code></pre></div></div>

<blockquote>
  <p>执行用时：56 ms, 在所有 Python3 提交中击败了95.70%的用户</p>

  <p>内存消耗：17.4 MB, 在所有 Python3 提交中击败了51.78%的用户</p>
</blockquote>

<p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/solution/mian-shi-ti-54-er-cha-sou-suo-shu-de-di-k-da-jie-d/">Link</a></p>

:ET